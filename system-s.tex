\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{amsmath,amssymb,amsfonts,mathtools,stmaryrd,stackrel}
%\setlength{\mathindent}{0pt}
\allowdisplaybreaks

\usepackage{listings}
\lstset{mathescape=true}
\newcommand{\lst}[1]{\lstinline!#1!}

\usepackage{bcprules}

\usepackage{tikz,tikz-cd}

% custom macros
\newcommand{\squarediamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1) (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\renewcommand{\square}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1);}}}
\renewcommand{\diamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\newcommand{\state}[1]{\ensuremath \langle #1 \rangle}
\newcommand{\transition}[2]{\ensuremath \state{#1} & \longrightarrow \state{#2}}
\newcommand{\termrule}[3]{\ensuremath #1 \xrightarrow{#2} #3}
\newcommand{\fail}{\ensuremath \uparrow}
\newcommand{\success}{\ensuremath \downarrow}
\newcommand{\cont}[2]{\ensuremath \mathbf{#1}(#2)}
\newcommand{\return}{\ensuremath \hookleftarrow}
\newcommand{\seq}[2]{\ensuremath #1 ; #2}
\newcommand{\choice}[2]{\ensuremath #1 + #2}
\newcommand{\leftchoice}[2]{\ensuremath #1 \mathrel{\vcenter{\hbox{+}}\mkern-18.5mu{\leftarrow}} #2}
\newcommand{\fix}[2]{\ensuremath \mu #1 (#2)}
\newcommand{\path}[2]{\ensuremath #1(#2)}
\newcommand{\one}[1]{\ensuremath \diamond(#1)}
\newcommand{\all}[1]{\ensuremath \square(#1)}
\newcommand{\some}[1]{\ensuremath \squarediamond(#1)}
\newcommand{\match}[1]{\ensuremath \text{match}(#1)}
\newcommand{\build}[1]{\ensuremath \text{build}(#1)}
\newcommand{\where}[1]{\ensuremath \text{where}(#1)}
\newcommand{\test}[1]{\ensuremath \text{test}(#1)}
\newcommand{\scope}[2]{\ensuremath \lbrace #1 : #2 \rbrace}
\newcommand{\vars}[1]{\ensuremath \text{vars}(#1)}
\newcommand{\alt}{\ensuremath \; | \;}
\newcommand{\Domain}{\ensuremath \mathcal{D}}
\newcommand{\Term}{\ensuremath \mathbb{T}}
\newcommand{\Fail}{\ensuremath \mathbb{F}}
\newcommand{\Var}{\ensuremath \mathbb{V}}
\newcommand{\Env}{\ensuremath \Var \mapsto \Term}
\newcommand{\Pow}[1]{\ensuremath \mathcal{P}(#1)}
\newcommand{\Fstrat}[1]{\ensuremath \text{Fstrat}\llbracket #1 \rrbracket}
\newcommand{\Fstratm}[1]{\ensuremath \text{Fstrat}_{-}\llbracket #1 \rrbracket}
\newcommand{\Fstratp}[1]{\ensuremath \text{Fstrat}_{+}\llbracket #1 \rrbracket}
\newcommand{\Fstrata}[1]{\ensuremath \text{Fstrat}^\star\llbracket #1 \rrbracket}
\newcommand{\Fstratam}[1]{\ensuremath \text{Fstrat}^\star_{-}\llbracket #1 \rrbracket}
\newcommand{\Fstratap}[1]{\ensuremath \text{Fstrat}^\star_{+}\llbracket #1 \rrbracket}
\newcommand{\Bstrat}[1]{\ensuremath \text{Bstrat}\llbracket #1 \rrbracket}
\newcommand{\Bstratp}[1]{\ensuremath \text{Bstrat}_{+} \llbracket #1 \rrbracket}
\newcommand{\Bstratm}[1]{\ensuremath \text{Bstrat}_{-} \llbracket #1 \rrbracket}
\newcommand{\Bstratap}[1]{\ensuremath \text{Bstrat}_{+}^\star\llbracket #1 \rrbracket}
\newcommand{\Bstratam}[1]{\ensuremath \text{Bstrat}_{-}^\star\llbracket #1 \rrbracket}
\newcommand{\transform}[5]{#1, #2 \xrightarrow{#3} #4, #5}
\newcommand{\transformfail}[3]{#1, #2 \xrightarrow{#3}\ \fail}
\newcommand{\dom}[1]{\ensuremath \text{dom}(#1)}
\newcommand{\cjm}{\ensuremath \xmapsto{\text{\tiny cjm}}}
\newcommand{\mon}{\ensuremath \xmapsto{\text{\tiny mon}}}

\begin{document}

\section*{Operational semantics of System S}

\infrule[Test]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\test{s}}{t}{\rho}}

\infrule[Test-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\test{s}}}

\infrule[Neg]
  {\transformfail{t}{\rho}{s}}
  {\transform{t}{\rho}{\neg s}{t}{\rho}}

\infrule[Neg-Fail]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transformfail{t}{\rho}{\neg s}}

\infrule[Seq]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transform{t'}{\rho'}{s_2}{t''}{\rho''}}
  {\transform{t}{\rho}{\seq{s_1}{s_2}}{t''}{\rho''}}

\infrule[Seq-Fail-1]
  {\transformfail{t}{\rho}{s_1}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Seq-Fail-2]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transformfail{t'}{\rho'}{s_2}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-2]
  {\transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Left-Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-2]
  {\transformfail{t}{\rho}{s_1} \andalso \transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Rec]
  {\transform{t}{\rho}{s[x \coloneqq \fix{x}{s}]}{t'}{\rho'}}
  {\transform{t}{\rho}{\fix{x}{s}}{t'}{\rho'}}

\infrule[Rec-Fail]
  {\transformfail{t}{\rho}{s[x \coloneqq \fix{x}{s}]}}
  {\transformfail{t}{\rho}{\fix{x}{s}}}

\infrule[Path]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[Path-Fail]
  {\transformfail{t_i}{\rho}{s}}
  {\transformfail{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}}

\infrule[Path-Fail-Bounds]
  {i > n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\path{i}{s}}}

\infrule[Cong]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{f(s_1,\ldots,s_n)}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Cong-Fail]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{f(s_1,\ldots,s_n)}}

\infrule[Cong-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{g(t_1',\ldots,t_n')}}

\infrule[One]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\one{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[One-Fail]
  {\transformfail{t_1}{\rho}{s} \andalso \cdots \andalso \transformfail{t_n}{\rho}{s}}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\one{s}}}

\infrule[All]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[All-Fail]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}}

\infrule[Some]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } i \in M \\
   \transformfail{t_j}{\rho_j}{s} \land\ \rho_{j+1} = \rho_j \land t_j' = t_j \text{ for all } j \in \lbrace 1 \ldots n \rbrace \setminus M \\
   M \subseteq \lbrace 1 \ldots n \rbrace}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\some{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Some-Fail]
  {\transformfail{t_i}{\rho}{s} \text{ for all } 1 \leq i \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\some{s}}}

\infrule[Match-Not-In-Dom]
  {x \notin \dom{\rho}}
  {\transform{t}{\rho}{\match{x}}{t}{\rho[x \mapsto t]}}

\infrule[Match-In-Dom]
  {\rho(x) = t}
  {\transform{t}{\rho}{\match{x}}{t}{\rho}}

\infrule[Match-In-Dom-Fail]
  {\rho(x) \neq t}
  {\transformfail{t}{\rho}{\match{x}}}

\infrule[Match-Sub]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Sub-Fail]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i < k \\
   \transformfail{t_k}{\rho_k}{\match{t_k'}} \\
   k \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\match{g(t_1',\ldots,t_n')}}}

\infrule[Build]
  {\vars{t'} \subseteq \dom{\rho}}
  {\transform{t}{\rho}{\build{t'}}{\rho(t')}{\rho}}

\infrule[Build-Fail]
  {\vars{t'} \nsubseteq \dom{\rho}}
  {\transformfail{t}{\rho}{\build{t'}}}

\infrule[Where]
  {\transform{t}{\rho}{s}{\rho(t')}{\rho'}}
  {\transform{t}{\rho}{\where{s}}{t}{\rho'}}

\infrule[Where-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\where{s}}}

\infrule[Scope]
  {\transform{t}{\rho \setminus \mathbf{x}}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\scope{\mathbf{x}}{s}}{t'}{(\rho' \setminus \mathbf{x}) \cup (\rho | \mathbf{x})}}

\infrule[Scope-Fail]
  {\transformfail{t}{\rho \setminus \mathbf{x}}{s}}
  {\transformfail{t}{\rho}{\scope{\mathbf{x}}{s}}}

\section*{Forward and Backward Collection Semantics of System S}

\begin{align*}
  \Fstrat{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \cjm \Pow{\Term \times (\Env) + \Fail} \\
  \Fstrat{s}R &= \Fstratp{s}R \cup \Fstratm{s}R \\
  \Fstratp{s}R &= \lbrace (t',\rho') | \exists (t,\rho) \in R.\ \transform{t}{\rho}{s}{t'}{\rho'} \rbrace \\
  \Fstratm{s}R &= \lbrace \fail | \exists (t,\rho) \in R.\ \transformfail{t}{\rho}{s} \rbrace \\
  \Bstratp{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \cjm \Pow{\Term \times (\Env)} \cjm \Pow{\Term \times (\Env)} \\
  \Bstratp{s}(R)(P) &= \lbrace (t,\rho) \in R | \exists (t',\rho') \in P.\ \transform{t}{\rho}{s}{t'}{\rho'} \rbrace \\
  \Bstratm{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \cjm \Pow{\Term \times (\Env)} \\
  \Bstratm{s}(R) &= \lbrace (t,\rho) \in R | \transformfail{t}{\rho}{s} \rbrace \\
\end{align*}

%% The forward collection semantics $\Fstrat{s}R$ specifies the strongest postcondition that result terms and environment satisfy after the strategy $s$ has been executed in an environment and with an input term that satisfy $R$.

%% \noindent
%% Fstrat is a complete join morphism, i.e.
%% %
%% \begin{align*}
%%   \Fstrat{s}(\bigcup_{k \in N} R_k) = \bigcup_{k \in N}(\Fstrat{s}(R_k)),
%% \end{align*}
%% %
%% which implies monotony if $N = \lbrace 1, 2 \rbrace$ and $R_1 \subseteq R_2$ and $\emptyset$-strictness (when $N = \emptyset$)

%% \begin{align*}
%%   \Fstrat{s}\emptyset = \emptyset.
%% \end{align*}

Next we lift a monotonic predicate transformer into a domain of abstract predicate transformers:
%
\begin{align*}
  \langle \Pow{\Term \times (\Env)} \mon \Pow{\Term \times (\Env) + \Fail}, \dot{\subseteq} \rangle \stackrel[\alpha^\star]{\gamma^\star}{\leftrightarrows}
  \langle L_T \times (\Var \mapsto L_T) \mon L_T \times (\Var \mapsto L_T) + L_F, \dot{\sqsubseteq} \rangle
\end{align*}
%
with
%
\begin{align*}
  \alpha^\star(\varphi) &= \ddot{\alpha} \circ \varphi \circ \dot{\gamma} \\
  \gamma^\star(\psi) &= \ddot{\gamma} \circ \psi \circ \dot{\alpha}
\end{align*}

\begin{center}
\begin{tikzcd}
  \Pow{\Term \times (\Env)} \arrow[d, "\dot{\alpha}",xshift=0.1cm] \arrow[r, "\varphi"] & \Pow{\Term \times (\Env) + \Fail} \arrow[d, "\ddot{\alpha}",xshift=0.1cm] \\
  L_T \times (\Var \mapsto L_T) \arrow[u, "\dot{\gamma}",xshift=-0.1cm] \arrow[r, "\psi"] & L_T \times (\Var \mapsto L_T) + L_F \arrow[u, "\ddot{\gamma}",xshift=-0.1cm]
\end{tikzcd}
\end{center}

\paragraph{Soundness}

We require that the abstract predicate transformer $\psi$ provides an overestimate $\psi(d)$ of the postcondition $\varphi(\ddot{\gamma}(d))$ defined by the concrete predicate transformer:
%
\begin{align*}
  \varphi(\dot{\gamma}(d)) \subseteq \ddot{\gamma}(\psi(d)) \Longleftrightarrow
  \ddot{\alpha}(\varphi(\dot{\gamma}(d))) \sqsubseteq \psi(d) \Longleftrightarrow
  \alpha^\star(\varphi)(d) \sqsubseteq \psi(d)
\end{align*}

It follows that the abstract predicate transformer $\alpha^\star(\varphi)$ is the best sound overapproximation for the concrete predicate transformer $\varphi$.

Accordingly we define $\Fstrata{s}R = \Fstratap{s}R \sqcup \Fstratam{s}R$, s.t. it satisfies
\begin{align*}
  \alpha^\star(\Fstrat{s})R \sqsubseteq \Fstrata{s}R.
\end{align*}

We now proceed by induction on the structure of strategies: 
\begin{itemize}
\item Case $s = \test{s'}$:
  %
  \begin{align*}
    \Fstratap{\test{s'}}(R) &= \Bstratap{s'}(R) \\
    \Fstratam{\test{s'}}(R) &= \Fstratam{s'}(R) \\
    \Bstratap{\test{s'}}(R)(P) &= \Bstratap{s'}(R)(P) \\
    \Bstratam{\test{s'}}(R) &= \Bstratam{s'}(R)
  \end{align*}

\item Case $s = \neg{s'}$:
  %
  \begin{align*}
    \Fstratap{\neg{s'}}(R) &= \Bstratam{s'}(R) \\
    \Fstratam{\neg{s'}}(R) &= \Fstratap{s'}(R) \\
    \Bstratap{\neg{s'}}(R)(P) &= \Bstratam{s'}(R) \\
    \Bstratam{\neg{s'}}(R) &= \Bstratap{s'}(R)(\top)
  \end{align*}

\item Case $s = \seq{s_1}{s_2}$:
  %
  \begin{align*}
    \Fstratap{\seq{s_1}{s_2}}(R) &= \Fstratap{s_2}(\Fstratap{s_1}(R)) \\
    \Fstratam{\seq{s_1}{s_2}}(R) &= \Fstratam{s_1}(R) \sqcup \Fstratam{s_2}(\Fstratap{s_1}(R)) \\
    \Bstratap{\seq{s_1}{s_2}}(R)(P) &= \Bstratap{s_1}(R)(\Bstratap{s_2}(\Fstratap{s_1}(R))(P)) \\
    \Bstratam{\seq{s_1}{s_2}}(R) &= \Bstratam{s_1}(R) \sqcup \Bstratap{s_1}(R)(\Bstratam{s_2}(\Fstratap{s_1}(R)))
  \end{align*}

\item Case $s = \choice{s_1}{s_2}$:
  %
  \begin{align*}
    \Fstratap{\choice{s_1}{s_2}}(R) &= \Fstratap{s_1}(R) \sqcup \Fstratap{s_2}(R) \\
    \Fstratam{\choice{s_1}{s_2}}(R) &= \Fstratam{s_1}(R) \sqcap \Fstratam{s_2}(R) \\
    \Bstratap{\choice{s_1}{s_2}}(R)(P) &= \Bstratap{s_1}(R)(P) \sqcup \Bstratap{s_2}(R)(P) \\
    \Bstratam{\choice{s_1}{s_2}}(R) &= \Bstratam{s_1}(R) \sqcap \Bstratam{s_2}(R)
  \end{align*}

\item Case $s = \leftchoice{s_1}{s_2}$:
  %
  \begin{align*}
    \Fstratap{\leftchoice{s_1}{s_2}}(R) &= \Fstratap{s_1}(R) \sqcup \Fstratap{s_2}(\Bstratam{s_1}(R)) \\
    \Fstratam{\leftchoice{s_1}{s_2}}(R) &= \Fstratam{s_1}(R) \sqcap \Fstratam{s_2}(R) \\
    \Bstratap{\leftchoice{s_1}{s_2}}(R)(P) &= \Bstratap{s_1}(R)(P) \sqcup \Bstratap{s_2}(\Bstratam{s_1}(R))(P) \\
    \Bstratam{\leftchoice{s_1}{s_2}}(R) &= \Bstratam{s_1}(R) \sqcap \Bstratam{s_2}(R)
  \end{align*}

\item Case $s = \fix{x}{s'}$:
  %
  \begin{align*}
    \Fstratap{\fix{x}{s'}}(R) &= ? \\
    \Fstratam{\fix{x}{s'}}(R) &= ? \\
    \Bstratap{\fix{x}{s'}}(R)(P) &= ? \\
    \Bstratam{\fix{x}{s'}}(R) &= ?
  \end{align*}
\end{itemize}

Since
\begin{align*}
  \alpha^\star(\Fstratp{s})R &\sqsubseteq \Fstratap{s}R \\
  \alpha^\star(\Fstratm{s})R &\sqsubseteq \Fstratam{s}R,
\end{align*}
it holds that
\begin{align*}
   &\ \alpha^\star(\Fstrata{s})R \\
  =&\ \ddot{\alpha}(\Fstratp{s}(\dot{\gamma}(R)) \cup \Fstratm{s}(\dot{\gamma}(R))) \\
  \sqsubseteq&\ \ddot{\alpha}(\Fstratp{s}(\dot{\gamma}(R))) \sqcup \ddot{\alpha}(\Fstratm{s}(\dot{\gamma}(R))) \\
  \sqsubseteq&\ \Fstratap{s}R \sqcup \Fstratam{s}R \\
  =&\ \Fstrata{s}R
\end{align*}
if $\ddot{\alpha}$ satisfies
\begin{align*}
  \ddot{\alpha}(M \cup N) \sqsubseteq \ddot{\alpha}(M) \sqcup \ddot{\alpha}(N)
\end{align*}

\end{document}
