\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{enumerate}

\usepackage{amsmath,amssymb,amsfonts,mathtools,stmaryrd,stackrel}
%\setlength{\mathindent}{0pt}
\allowdisplaybreaks

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\usepackage{breqn}

\usepackage{listings}
\lstset{mathescape=true}
\newcommand{\lst}[1]{\lstinline!#1!}

\usepackage{bcprules}

\usepackage{tikz,tikz-cd}

% custom macros
\newcommand{\minus}{{\scalebox{0.9}{-}}}
\newcommand{\plus}{{\scalebox{0.6}{\!+}}}
\newcommand{\squarediamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1) (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\renewcommand{\square}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1);}}}
\renewcommand{\diamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\newcommand{\state}[1]{\ensuremath \langle #1 \rangle}
\newcommand{\transition}[2]{\ensuremath \state{#1} & \longrightarrow \state{#2}}
\newcommand{\termrule}[3]{\ensuremath #1 \xrightarrow{#2} #3}
\newcommand{\fail}{\ensuremath \text{$\uparrow$}}
\newcommand{\success}{\ensuremath \text{$\downarrow$}}
\newcommand{\cont}[2]{\ensuremath \mathbf{#1}(#2)}
\newcommand{\return}{\ensuremath \hookleftarrow}
\newcommand{\seq}[2]{\ensuremath #1 ; #2}
\newcommand{\choice}[2]{\ensuremath #1 + #2}
\newcommand{\leftchoice}[2]{\ensuremath #1 \mathrel{\vcenter{\hbox{+}}\mkern-18.5mu{\leftarrow}} #2}
\newcommand{\fix}[2]{\ensuremath \text{rec}(#1,#2)}
\newcommand{\path}[2]{\ensuremath \text{path}(#1,#2)}
\newcommand{\one}[1]{\ensuremath \text{one}(#1)}
\newcommand{\all}[1]{\ensuremath \text{all}(#1)}
\newcommand{\some}[1]{\ensuremath \text{some}(#1)}
\newcommand{\congr}[1]{\ensuremath \text{cong}(#1)}
\newcommand{\match}[1]{\ensuremath \text{match}(#1)}
\newcommand{\build}[1]{\ensuremath \text{build}(#1)}
\newcommand{\where}[1]{\ensuremath \text{where}(#1)}
\newcommand{\test}[1]{\ensuremath \operatorname{test}(#1)}
\newcommand{\scope}[2]{\ensuremath \lbrace #1 : #2 \rbrace}
\newcommand{\vars}[1]{\ensuremath \text{vars}(#1)}
\newcommand{\alt}{\ensuremath \; | \;}

\newcommand{\transform}[5]{#1, #2 \xrightarrow{#3} #4, #5}
\newcommand{\transformx}[4]{#1, #2 \xrightarrow{#3} #4}
\newcommand{\transformfail}[3]{#1, #2 \xrightarrow{#3} \fail}
\newcommand{\dom}[1]{\ensuremath \text{dom}(#1)}
\newcommand{\cjm}{\ensuremath \xmapsto{\text{\tiny cjm}}}
\newcommand{\mon}{\ensuremath \xmapsto{\text{\tiny mon}}}

\newcommand{\Term}{\ensuremath \mathbb{T}}
\newcommand{\Fail}{\ensuremath \mathbb{F}}
\newcommand{\Var}{\ensuremath \mathbb{V}}
\newcommand{\Env}{\ensuremath \Var \mapsto \Term}
\newcommand{\Pow}[1]{\ensuremath \mathcal{P}(#1)}
\newcommand{\sem}[1]{\ensuremath \llbracket #1 \rrbracket}

\newcommand{\State}{\ensuremath \text{State}}
\newcommand{\Statea}{\ensuremath \widehat{\State}}

\newcommand{\absstate}{\ensuremath \alpha_\sigma }
\newcommand{\absstateprod}{\ensuremath \alpha_{\sigma\times\sigma} }
\newcommand{\absstateprodfail}{\ensuremath \alpha_{\sigma\times\sigma_\fail} }
\newcommand{\constate}{\ensuremath \gamma_\sigma }
\newcommand{\absfail}{\ensuremath \alpha_\fail }
\newcommand{\confail}{\ensuremath \gamma_\fail }
\newcommand{\absstatefail}{\ensuremath \alpha_{\sigma_\fail} }
\newcommand{\constatefail}{\ensuremath \gamma_{\sigma_\fail} }

\newcommand{\setbuild}[2]{\ensuremath \left\{\, #1 \mid #2 \,\right\}}

\newcommand{\id}{\ensuremath \operatorname{id}}
\newcommand{\lfail}{\ensuremath \fail^{\star}}
\newcommand{\lsucc}{\ensuremath \success^{\star}}
\newcommand{\Rel}{\ensuremath \mathbf{Rel}}
\newcommand{\Naive}{\ensuremath \mathbf{Naive}}
\newcommand{\adjoint}{\ensuremath \dashv}
\newcommand{\lub}{\ensuremath \bigsqcup}

\begin{document}

\section*{Operational semantics of System S}

\infrule[Test]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\test{s}}{t}{\rho}}

\infrule[Test-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\test{s}}}

\infrule[Neg]
  {\transformfail{t}{\rho}{s}}
  {\transform{t}{\rho}{\neg s}{t}{\rho}}

\infrule[Neg-Fail]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transformfail{t}{\rho}{\neg s}}

\infrule[Seq]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transform{t'}{\rho'}{s_2}{t''}{\rho''}}
  {\transform{t}{\rho}{\seq{s_1}{s_2}}{t''}{\rho''}}

\infrule[Seq-Fail-1]
  {\transformfail{t}{\rho}{s_1}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Seq-Fail-2]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transformfail{t'}{\rho'}{s_2}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-2]
  {\transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Left-Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-2]
  {\transformfail{t}{\rho}{s_1} \andalso \transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Rec]
  {\transform{t}{\rho}{s[x \coloneqq \fix{x}{s}]}{t'}{\rho'}}
  {\transform{t}{\rho}{\fix{x}{s}}{t'}{\rho'}}

\infrule[Rec-Fail]
  {\transformfail{t}{\rho}{s[x \coloneqq \fix{x}{s}]}}
  {\transformfail{t}{\rho}{\fix{x}{s}}}

\infrule[Path]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[Path-Fail]
  {\transformfail{t_i}{\rho}{s}}
  {\transformfail{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}}

\infrule[Path-Fail-Bounds]
  {i > n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\path{i}{s}}}

\infrule[Cong]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\congr{f,s_1,\ldots,s_n}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Cong-Fail]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{\congr{f,s_1,\ldots,s_n}}}

\infrule[Cong-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\congr{g,t_1',\ldots,t_n'}}}

\infrule[Cong-Arity-Fail]
  {n \neq n'}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\congr{g,t_1',\ldots,t_{n'}'}}}

\infrule[One]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\one{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[One-Fail]
  {\transformfail{t_1}{\rho}{s} \andalso \cdots \andalso \transformfail{t_n}{\rho}{s}}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\one{s}}}

\infrule[All]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[All-Fail]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}}

\infrule[Some]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } i \in M \\
   \transformfail{t_j}{\rho_j}{s} \land\ \rho_{j+1} = \rho_j \land t_j' = t_j \text{ for all } j \in \overline{M} \\
   M \subseteq \lbrace 1 \ldots n \rbrace}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\some{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Some-Fail]
  {\transformfail{t_i}{\rho}{s} \text{ for all } 1 \leq i \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\some{s}}}

\infrule[Match-Not-In-Dom]
  {x \notin \dom{\rho}}
  {\transform{t}{\rho}{\match{x}}{t}{\rho[x \mapsto t]}}

\infrule[Match-In-Dom]
  {\rho(x) = t}
  {\transform{t}{\rho}{\match{x}}{t}{\rho}}

\infrule[Match-In-Dom-Fail]
  {\rho(x) \neq t}
  {\transformfail{t}{\rho}{\match{x}}}

\infrule[Match-Sub]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Sub-Fail]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i < k \\
   \transformfail{t_k}{\rho_k}{\match{t_k'}} \\
   k \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\match{g(t_1',\ldots,t_n')}}}

\infrule[Build]
  {\vars{t'} \subseteq \dom{\rho}}
  {\transform{t}{\rho}{\build{t'}}{\rho(t')}{\rho}}

\infrule[Build-Fail]
  {\vars{t'} \nsubseteq \dom{\rho}}
  {\transformfail{t}{\rho}{\build{t'}}}

\infrule[Where]
  {\transform{t}{\rho}{s}{\rho(t')}{\rho'}}
  {\transform{t}{\rho}{\where{s}}{t}{\rho'}}

\infrule[Where-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\where{s}}}

\infrule[Scope]
  {\transform{t}{\rho \setminus \mathbf{x}}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\scope{\mathbf{x}}{s}}{t'}{(\rho' \setminus \mathbf{x}) \cup (\rho | \mathbf{x})}}

\infrule[Scope-Fail]
  {\transformfail{t}{\rho \setminus \mathbf{x}}{s}}
  {\transformfail{t}{\rho}{\scope{\mathbf{x}}{s}}}

\clearpage
\section*{Abstract Interpretation}

% \begin{definition} \normalfont
%   A product of objects $A$ and $B$ in a category is an object $P$ together with two arrows $\pi_1 : P \rightarrow A$ and $\pi_2 : P \rightarrow B$, s.t. for all objects $X$ and arrows $f: X \rightarrow A$, $g: X \rightarrow B$ there exists a unique arrow $h: X \rightarrow P$ and the following diagram commutes:
%   \[
%   \begin{tikzcd}
%       & X \arrow[ld,"f" above]    \arrow[d,dotted,"h"] \arrow[rd,"g"] &   \\
%     A & P \arrow[l,"\pi_1" above]                      \arrow[r,"\pi_2"] & B
%   \end{tikzcd}
%   \]

% We denote the unique arrow $h$ with $f \times g$.
% \end{definition}

% \begin{definition} \normalfont
%   Dually, a coproduct of objects $A$ and $B$ in a category is an object $P$ together with two arrows $i_1 : A \rightarrow P$ and $i_2 : B \rightarrow P$, s.t. for all objects $X$ and arrows $f: A \rightarrow X$, $g: B \rightarrow X$ there exists a unique arrow $h: P \rightarrow X$ and the following diagram commutes:
%   \[
%   \begin{tikzcd}
%     A \arrow[r,"i_1" above] \arrow[rd,"f" above] &
%     P \arrow[d,dotted,"h" right] &
%     B \arrow[l,"i_2" above] \arrow[ld,"g" above] \\
%     & X  &
%   \end{tikzcd}
% \]

% We denote the unique arrow $h$ with $f + g$.
% \end{definition}

% \begin{definition}[Meet (Join) preserving functors] \normalfont
% We say that a functor $F$ between two lattices $(L_1,\leq_{L_1},\cup,\cap)$ and $(L_2,\leq_{L_2},\sqcup,\sqcap)$ preserves binary meets (joins) iff for all $x,y \in L_1$,
% \[ F(x \cup y) = F(x) \sqcup F(y) \] respectively 
% \[ F(x \cap y) = F(f) \sqcap F(y). \]
% \end{definition}

% \begin{definition}[Product preserving functors] \normalfont
%   We say that a functor $F : \mathcal{C} \rightarrow \mathcal{D}$ preserves products iff for all products $P$ of $A$ and $B$, arrows $f: X \rightarrow A$ and $g: X \rightarrow B$, $F(P)$ is a product of $F(A)$ and $F(B)$ in $\mathcal{D}$ and \[ F(f \times_{\mathcal{C}} g) = F(f) \times_{\mathcal{D}} F(g).\]
%   \[
%   \begin{tikzcd}
%       & X \arrow[ld,"f" above]    \arrow[d,dotted,"h"] \arrow[rd,"g"] &      & \mathcal{C} \arrow[ddd,"F"]  \\
%     A & P \arrow[l,"\pi_1" above]                      \arrow[r,"\pi_2"] & B & \\
%       & F(X) \arrow[ld,"F(f)" above]    \arrow[d,dotted,"F(h)"] \arrow[rd,"F(g)"] &      & \\
%     F(A) & F(P) \arrow[l,"F(\pi_1)" above]                      \arrow[r,"F(\pi_2)"] & F(B) & \mathcal{D}\\
%   \end{tikzcd}
%   \]
% \end{definition}

\begin{definition}[$\Rel$ Category] \normalfont
  We define the category of relations $\Rel$, with sets $A,B,C, \ldots$ as objects, binary relation $R,S,T, \ldots$ as arrows where $R: A \rightarrow B$ if $R \subseteq A \times B$. The identity arrow \[id_A \coloneqq \setbuild{ (x,x) }{ x \in A }.\] The composition of relations \[R \circ S \coloneqq \setbuild{(x,z)}{ \exists y. (x,y) \in S \land (y,z) \in R }.\] Additionally we define an unary operation that reverses a relation \[ R^{-1} = \setbuild{(y,x)}{ \forall (x,y) \in R } \]   
\end{definition}

\begin{definition}[$\Rel(A)$ Category] \normalfont
  We define the category $\Rel(A)$ as a proper subcategory of $\Rel$, where the all the objects are subsets of $A$.
\end{definition}

\begin{definition}[System S Programm State] \normalfont
  We define the state space of System S programs as \[\State \coloneqq \Term \times \Env \cup \Fail,\] the set of all terms together with a term environment or failure.
\end{definition}

We can think of the category $\Rel(\State)$ as a category that has properties of program states as objects and properties of program transitions as arrows.

\begin{definition}[Concrete Denotational Semantics of System S] \normalfont
  We define the denotational semantics of System S programs as a relation over $\State \times \State$ with \[\sem{s} \coloneqq \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}.\]
\end{definition}

\begin{theorem} \normalfont The concrete semantics of System S can be expressed with an algebra of the signature $(\cup, \cap, \circ, (-)^{-1})$.
\begin{proof}
\begin{dgroup*}
\begin{dmath*}
  \sem{\test{s}}
     = {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\test{s}}{x}}}
     = {\setbuild{((t,\rho),(t,\rho))}{\transform{t}{\rho}{s}{t'}{\rho'}}} \cup
       {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s}}}
     = ({\setbuild{((t,\rho),(t,\rho))}{\forall t,\rho}} \circ
        {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}})^{-1}
       \circ
       ({\setbuild{((t,\rho),(t,\rho))}{\forall t,\rho}} \circ
        {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}}) \cup
       {\setbuild{((t,\rho),\fail)}{\forall t, \rho}} \circ
       {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}}
     = (\success \circ \sem{s})^{-1} \circ (\success \circ \sem{s}) \cup
       \fail \circ \sem{s}
\end{dmath*}
     
\begin{dmath*}
  \sem{\neg{s}}
    = {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\neg{s}}{x}}}
    = {\setbuild{((t,\rho),(t,\rho))}{\transformfail{t}{\rho}{s}}} \cup
      {\setbuild{((t,\rho),\fail)}{\transform{t}{\rho}{s}{t'}{\rho'}}}
    = ({\setbuild{((t,\rho),\fail)}{\forall t,\rho}} \circ
       {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}})^{-1}
      \circ
      ({\setbuild{((t,\rho),\fail)}{\forall t,\rho}} \circ
       {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}})
      \cup
      {\setbuild{((t,\rho),\fail)}{\forall t, \rho}} \circ
      {\setbuild{((t,\rho),(t,\rho))}{\forall t, \rho}} \circ
      {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}}
    = (\fail \circ \sem{s})^{-1} \circ (\fail \circ \sem{s}) \cup
       \fail \circ \success \circ \sem{s}
\end{dmath*}

\begin{dmath*}
  \sem{\seq{s_1}{s_2}}
    = {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\seq{s_1}{s_2}}{x}}}
    = {\setbuild{((t,\rho),(t'',\rho''))}{\transform{t}{\rho}{s_1}{t'}{\rho'} \land \transform{t'}{\rho'}{s_2}{t''}{\rho''}}} \cup
                  {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s_1}}} \cup
                  {\setbuild{((t,\rho),\fail)}{\transform{t}{\rho}{s_1}{t'}{\rho'} \land \transformfail{t'}{\rho'}{s_2}}}
    = {\setbuild{((t,\rho),x)}{\transform{t}{\rho}{s_1}{t'}{\rho'} \land \transformx{t'}{\rho'}{s_2}{x}}} \cup
                  {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s_1}}}
    = {\setbuild{((t,\rho),x)}{\transformx{t'}{\rho'}{s_2}{x}}} \circ
      {\setbuild{((t,\rho),x)}{\transformx{t'}{\rho'}{s_1}{x}}} \cup
      {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s_1}}}
    = \sem{s_2} \circ \sem{s_1} \cup \fail \circ \sem{s_1}
\end{dmath*}

\begin{dmath*}
  \sem{\choice{s_1}{s_2}}
     = {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\choice{s_1}{s_2}}{x}}}
     = {\setbuild{((t,\rho),(t',\rho'))}{\transform{t}{\rho}{s_1}{t'}{\rho'}}} \cup
       {\setbuild{((t,\rho),(t',\rho'))}{\transform{t}{\rho}{s_2}{t'}{\rho'}}} \cup
       {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s_1} \land \transformfail{t'}{\rho'}{s_2}}}
     = {\setbuild{((t,\rho),(t,\rho))}{\forall t, \rho}} \circ
       {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}}} \cup
       {\setbuild{((t,\rho),(t,\rho))}{\forall t, \rho}} \circ
       {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_2}{x}}} \cup
       ({\setbuild{((t,\rho),\fail)}{\forall t, \rho}} \circ
        {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}}} \cap
        {\setbuild{((t,\rho),\fail)}{\forall t, \rho}} \circ
        {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_2}{x}}})
     = \success \circ \sem{s_1} \cup \success \circ \sem{s_2} \cup (\fail \circ \sem{s_1} \cap \fail \circ \sem{s_2})
\end{dmath*}
\end{dgroup*}
\end{proof}
\end{theorem}

\begin{definition}[Galois Connection] \normalfont
  A Galois Connection is an adjunction between two posets $A$ and $B$ with a left adjoint functor $\alpha : A \rightarrow B$ called \emph{abstraction} and a right adjoint functor $\gamma : B \rightarrow A$ called \emph{concretisation}
 and for all $x \in A$ and $y \in B$, the following two-way rule holds \[ \frac{\alpha(x) \leq_B y}{x \leq_A \gamma(y)}. \]
\end{definition}

\begin{definition}[$(L,\alpha,\gamma)$-Semantics of System S] \normalfont
  We define the abstract semantics of System S programs as values in a lattice $L$ over a given galois connection $\alpha \adjoint \gamma$ as \[\sem{s}_{(L,\alpha,\gamma)} \coloneqq \alpha(\sem{s}). \]
\end{definition}

We begin exploring the space of $(L,\alpha,\gamma)$-Semantics of System S by defining a very naive abstraction, namely where an abstract state consists only of a single term and on conflict we jump immmediatley to top:
 
\begin{definition}[$\Naive$ semantics of System S] \normalfont
  Let $N$ be the set of abstract program states with $N = \State \cup \lbrace \top, \bot \rbrace$. We define a complete partial order $\leq_N$ on $N$
  \[
    \begin{tikzpicture}
     \matrix (m) [matrix of math nodes, row sep=3em, column sep=3em]
    {          & \top &       \\
      (t,\rho) &      & \fail \\
               & \bot &       \\
    };

    \draw [thick] (m-2-1) -- (m-1-2);
    \draw [thick] (m-2-3) -- (m-1-2);
    \draw [thick] (m-3-2) -- (m-2-1);
    \draw [thick] (m-3-2) -- (m-2-3);
    \end{tikzpicture}
  \]

  We next define the category $\Naive$ where objects are elements of $N$, arrows are tuples $(x,y) : x \rightarrow y$ for $(x,y) \in N \times N$, the identity $\id_x = (x,x)$, and  composition $(y,z) \circ (x,y) = (x,z).$

  We continue by defining the abstraction functor $\alpha : \Rel(\State) \rightarrow \Naive$, for objects $S \subseteq \State$ by
  \[
     \alpha(S) \coloneqq \lub S
  \]
  and arrows $R : A \rightarrow B \subseteq \State \times \State$ by
  \[
     \alpha(R) \coloneqq (\lub A, \lub B).
  \]

   
\end{definition}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
