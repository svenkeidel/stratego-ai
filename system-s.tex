\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{amsmath,amssymb,amsfonts,mathtools,stmaryrd,stackrel}
%\setlength{\mathindent}{0pt}
\allowdisplaybreaks

\usepackage{listings}
\lstset{mathescape=true}
\newcommand{\lst}[1]{\lstinline!#1!}

\usepackage{bcprules}

\usepackage{tikz,tikz-cd}

% custom macros
\newcommand{\minus}{{\scalebox{0.9}{-}}}
\newcommand{\plus}{{\scalebox{0.6}{\!+}}}
\newcommand{\squarediamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1) (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\renewcommand{\square}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1);}}}
\renewcommand{\diamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\newcommand{\state}[1]{\ensuremath \langle #1 \rangle}
\newcommand{\transition}[2]{\ensuremath \state{#1} & \longrightarrow \state{#2}}
\newcommand{\termrule}[3]{\ensuremath #1 \xrightarrow{#2} #3}
\newcommand{\fail}{\ensuremath \uparrow}
\newcommand{\lfail}{\ensuremath \uparrow_{L_F}}
\newcommand{\success}{\ensuremath \downarrow}
\newcommand{\cont}[2]{\ensuremath \mathbf{#1}(#2)}
\newcommand{\return}{\ensuremath \hookleftarrow}
\newcommand{\seq}[2]{\ensuremath #1 ; #2}
\newcommand{\choice}[2]{\ensuremath #1 + #2}
\newcommand{\leftchoice}[2]{\ensuremath #1 \mathrel{\vcenter{\hbox{+}}\mkern-18.5mu{\leftarrow}} #2}
\newcommand{\fix}[2]{\ensuremath \mu #1 (#2)}
\newcommand{\path}[2]{\ensuremath #1(#2)}
\newcommand{\one}[1]{\ensuremath \diamond(#1)}
\newcommand{\all}[1]{\ensuremath \square(#1)}
\newcommand{\some}[1]{\ensuremath \squarediamond(#1)}
\newcommand{\match}[1]{\ensuremath \text{match}(#1)}
\newcommand{\build}[1]{\ensuremath \text{build}(#1)}
\newcommand{\where}[1]{\ensuremath \text{where}(#1)}
\newcommand{\test}[1]{\ensuremath \text{test}(#1)}
\newcommand{\scope}[2]{\ensuremath \lbrace #1 : #2 \rbrace}
\newcommand{\vars}[1]{\ensuremath \text{vars}(#1)}
\newcommand{\alt}{\ensuremath \; | \;}

\newcommand{\transform}[5]{#1, #2 \xrightarrow{#3} #4, #5}
\newcommand{\transformfail}[3]{#1, #2 \xrightarrow{#3}\ \fail}
\newcommand{\dom}[1]{\ensuremath \text{dom}(#1)}
\newcommand{\cjm}{\ensuremath \xmapsto{\text{\tiny cjm}}}
\newcommand{\mon}{\ensuremath \xmapsto{\text{\tiny mon}}}

\newcommand{\Term}{\ensuremath \mathbb{T}}
\newcommand{\Fail}{\ensuremath \mathbb{F}}
\newcommand{\Var}{\ensuremath \mathbb{V}}
\newcommand{\Env}{\ensuremath \Var \mapsto \Term}
\newcommand{\Pow}[1]{\ensuremath \mathcal{P}(#1)}
\newcommand{\Fstrat}[1]{\ensuremath \text{Fstrat}\llbracket #1 \rrbracket}
\newcommand{\Fstratm}[1]{\ensuremath \text{Fstrat}_\minus \llbracket #1 \rrbracket}
\newcommand{\Fstratp}[1]{\ensuremath \text{Fstrat}_\plus \llbracket #1 \rrbracket}
\newcommand{\Fstrata}[1]{\ensuremath \text{Fstrat}^\triangleright \llbracket #1 \rrbracket}
\newcommand{\Fstratam}[1]{\ensuremath \text{Fstrat}^\triangleright_\minus \llbracket #1 \rrbracket}
\newcommand{\Fstratap}[1]{\ensuremath \text{Fstrat}^\triangleright_\plus \llbracket #1 \rrbracket}
\newcommand{\Bstrat}[1]{\ensuremath \text{Bstrat}\llbracket #1 \rrbracket}
\newcommand{\Bstratp}[1]{\ensuremath \text{Bstrat}_\plus \llbracket #1 \rrbracket}
\newcommand{\Bstratm}[1]{\ensuremath \text{Bstrat}_\minus \llbracket #1 \rrbracket}
\newcommand{\Bstrata}[1]{\ensuremath \text{Bstrat}^\triangleleft \llbracket #1 \rrbracket}
\newcommand{\Bstratap}[1]{\ensuremath \text{Bstrat}_\plus^\triangleleft \llbracket #1 \rrbracket}
\newcommand{\Bstratam}[1]{\ensuremath \text{Bstrat}_\minus^\triangleleft \llbracket #1 \rrbracket}
\newcommand{\State}{\ensuremath \text{State}}
\newcommand{\Statef}{\ensuremath \text{State}_\fail}
\newcommand{\Statea}{\ensuremath \widehat{\text{State}}}
\newcommand{\Stateaf}{\ensuremath \widehat{\text{State}}_\fail}
\newcommand{\Statefail}{\ensuremath L_F}

\newcommand{\fpathp}{\ensuremath \text{path}^\triangleright_\plus}
\newcommand{\fpathm}{\ensuremath \text{path}^\triangleright_\minus}
\newcommand{\bpathp}{\ensuremath \text{path}^\triangleleft_\plus}
\newcommand{\bpathm}{\ensuremath \text{path}^\triangleleft_\minus}

\newcommand{\fallap}{\ensuremath \text{all}^\triangleright_\plus}
\newcommand{\fallam}{\ensuremath \text{all}^\triangleright_\minus}
\newcommand{\ballap}{\ensuremath \text{all}^\triangleleft_\plus}
\newcommand{\ballam}{\ensuremath \text{all}^\triangleleft_\minus}

\newcommand{\absstate}{\ensuremath \alpha_\sigma }
\newcommand{\constate}{\ensuremath \gamma_\sigma }
\newcommand{\absfail}{\ensuremath \alpha_\fail }
\newcommand{\confail}{\ensuremath \gamma_\fail }
\newcommand{\absstatefail}{\ensuremath \alpha_{\sigma\fail} }
\newcommand{\constatefail}{\ensuremath \gamma_{\sigma\fail} }

\begin{document}

\section*{Operational semantics of System S}

\infrule[Test]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\test{s}}{t}{\rho}}

\infrule[Test-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\test{s}}}

\infrule[Neg]
  {\transformfail{t}{\rho}{s}}
  {\transform{t}{\rho}{\neg s}{t}{\rho}}

\infrule[Neg-Fail]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transformfail{t}{\rho}{\neg s}}

\infrule[Seq]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transform{t'}{\rho'}{s_2}{t''}{\rho''}}
  {\transform{t}{\rho}{\seq{s_1}{s_2}}{t''}{\rho''}}

\infrule[Seq-Fail-1]
  {\transformfail{t}{\rho}{s_1}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Seq-Fail-2]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transformfail{t'}{\rho'}{s_2}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-2]
  {\transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Left-Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-2]
  {\transformfail{t}{\rho}{s_1} \andalso \transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Rec]
  {\transform{t}{\rho}{s[x \coloneqq \fix{x}{s}]}{t'}{\rho'}}
  {\transform{t}{\rho}{\fix{x}{s}}{t'}{\rho'}}

\infrule[Rec-Fail]
  {\transformfail{t}{\rho}{s[x \coloneqq \fix{x}{s}]}}
  {\transformfail{t}{\rho}{\fix{x}{s}}}

\infrule[Path]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[Path-Fail]
  {\transformfail{t_i}{\rho}{s}}
  {\transformfail{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}}

\infrule[Path-Fail-Bounds]
  {i > n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\path{i}{s}}}

\infrule[Cong]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{f(s_1,\ldots,s_n)}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Cong-Fail]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{f(s_1,\ldots,s_n)}}

\infrule[Cong-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{g(t_1',\ldots,t_n')}}

\infrule[One]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\one{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[One-Fail]
  {\transformfail{t_1}{\rho}{s} \andalso \cdots \andalso \transformfail{t_n}{\rho}{s}}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\one{s}}}

\infrule[All]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[All-Fail]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}}

\infrule[Some]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } i \in M \\
   \transformfail{t_j}{\rho_j}{s} \land\ \rho_{j+1} = \rho_j \land t_j' = t_j \text{ for all } j \in \lbrace 1 \ldots n \rbrace \setminus M \\
   M \subseteq \lbrace 1 \ldots n \rbrace}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\some{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Some-Fail]
  {\transformfail{t_i}{\rho}{s} \text{ for all } 1 \leq i \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\some{s}}}

\infrule[Match-Not-In-Dom]
  {x \notin \dom{\rho}}
  {\transform{t}{\rho}{\match{x}}{t}{\rho[x \mapsto t]}}

\infrule[Match-In-Dom]
  {\rho(x) = t}
  {\transform{t}{\rho}{\match{x}}{t}{\rho}}

\infrule[Match-In-Dom-Fail]
  {\rho(x) \neq t}
  {\transformfail{t}{\rho}{\match{x}}}

\infrule[Match-Sub]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Sub-Fail]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i < k \\
   \transformfail{t_k}{\rho_k}{\match{t_k'}} \\
   k \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\match{g(t_1',\ldots,t_n')}}}

\infrule[Build]
  {\vars{t'} \subseteq \dom{\rho}}
  {\transform{t}{\rho}{\build{t'}}{\rho(t')}{\rho}}

\infrule[Build-Fail]
  {\vars{t'} \nsubseteq \dom{\rho}}
  {\transformfail{t}{\rho}{\build{t'}}}

\infrule[Where]
  {\transform{t}{\rho}{s}{\rho(t')}{\rho'}}
  {\transform{t}{\rho}{\where{s}}{t}{\rho'}}

\infrule[Where-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\where{s}}}

\infrule[Scope]
  {\transform{t}{\rho \setminus \mathbf{x}}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\scope{\mathbf{x}}{s}}{t'}{(\rho' \setminus \mathbf{x}) \cup (\rho | \mathbf{x})}}

\infrule[Scope-Fail]
  {\transformfail{t}{\rho \setminus \mathbf{x}}{s}}
  {\transformfail{t}{\rho}{\scope{\mathbf{x}}{s}}}

\section*{Forward and Backward Collection Semantics of System S}

\begin{align*}
  \Fstrat{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \cjm \Pow{\Term \times (\Env) + \Fail} \\
  \Fstrat{s}R &= \Fstratp{s}(R) \cup \Fstratm{s}(R) \\
  \Fstratp{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \cjm \Pow{\Term \times (\Env)} \\
  \Fstratp{s}R &= \lbrace (t',\rho')\ |\ \exists (t,\rho) \in R.\ \transform{t}{\rho}{s}{t'}{\rho'} \rbrace \\
  \Fstratm{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \cjm \Pow{\Fail} \\
  \Fstratm{s}R &= \lbrace \fail\ |\ \exists (t,\rho) \in R.\ \transformfail{t}{\rho}{s} \rbrace \\
  \Bstrat{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \times \Pow{\Term \times (\Env) + \Fail} \cjm \Pow{\Term \times (\Env)} \\
  \Bstrat{s}(R,P) &= \Bstratp{s}(R,P \cap (\Term \times (\Env))) \cup \Bstratm{s}(R,P \cap \Fail) \\
  \Bstratp{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \times \Pow{\Term \times (\Env)} \cjm \Pow{\Term \times (\Env)} \\
  \Bstratp{s}(R,P) &= \lbrace (t,\rho) \in R\ |\ \exists (t',\rho') \in P.\ \transform{t}{\rho}{s}{t'}{\rho'} \rbrace \\
  \Bstratm{\mathbf{strat}} &: \Pow{\Term \times (\Env)} \times \Pow{\Fail} \cjm \Pow{\Term \times (\Env)} \\
  \Bstratm{s}(R,F) &= \lbrace (t,\rho) \in R\ |\ \exists \fail\ \in F. \transformfail{t}{\rho}{s} \rbrace \\
  \State &= \Pow{\Term \times (\Env)} \\
  \Statef &= \Pow{\Term \times (\Env) + \Fail} \\
  \Statea &= L_T \times (\Var \mapsto L_T) \\
  \Stateaf &= L_T \times (\Var \mapsto L_T) + L_F
\end{align*}

\begin{center}
\begin{tikzcd}
  \Statea \arrow[d, "\constate",xshift=0.07cm] \arrow[r, "\text{Fstrat}^\triangleright"] & \Stateaf \arrow[d, "\constatefail",xshift=0.07cm] \\
  \State \arrow[u, "\absstate",xshift=-0.07cm] \arrow[r, "\text{Fstrat}"] & \Statef \arrow[u, "\absstatefail",xshift=-0.07cm]
\end{tikzcd}
\end{center}

\begin{center}
\begin{tikzcd}
  \Statea \times \Stateaf \arrow[d, "\constate \times \constatefail",xshift=0.07cm] \arrow[r, "\text{Bstrat}^\triangleleft"] & \Statea \arrow[d, "\constate",xshift=0.07cm] \\
  \State \times \Statef \arrow[u, "\absstate \times \absstatefail",xshift=-0.07cm] \arrow[r, "\text{Bstrat}"] & \State \arrow[u, "\absstate",xshift=-0.07cm]
\end{tikzcd}
\end{center}

\paragraph{Soundness}

\begin{align*}
  \alpha^\star(\varphi) &= \ddot{\alpha} \circ \varphi \circ \dot{\gamma} \\
  \gamma^\star(\psi) &= \ddot{\gamma} \circ \psi \circ \dot{\alpha} \\
  \alpha^\star(\Fstrat{s})r &\sqsubseteq \Fstrata{s}r \\
  \alpha^\star(\Bstrat{s})(r,p) &\sqsubseteq \Bstrata{s}(r,p)
\end{align*}

We now proceed by induction on the structure of strategies: 
\begin{itemize}
\item Case $s = \test{s'}$:
  %
  \begin{align*}
    \Fstratap{\test{s'}}(r) &= \Bstratap{s'}(r,\top) \\
    \Fstratam{\test{s'}}(r) &= \Fstratam{s'}(r) \\
    \Bstratap{\test{s'}}(r,p) &= \Bstratap{s'}(r,p) \\
    \Bstratam{\test{s'}}(r,p) &= \Bstratam{s'}(r,p)
  \end{align*}

\item Case $s = \neg{s'}$:
  %
  \begin{align*}
    \Fstratap{\neg{s'}}(r) &= \Bstratam{s'}(r) \\
    \Fstratam{\neg{s'}}(r) &= \Fstratap{s'}(r) \\
    \Bstratap{\neg{s'}}(r,p) &= \Bstratam{s'}(r,\lfail) \\
    \Bstratam{\neg{s'}}(r,p) &= \Bstratap{s'}(r,\top)
  \end{align*}

\item Case $s = \seq{s_1}{s_2}$:
  %
  \begin{align*}
    \Fstratap{\seq{s_1}{s_2}}(r) &= \Fstratap{s_2}(\Fstratap{s_1}(r)) \\
    \Fstratam{\seq{s_1}{s_2}}(r) &= \Fstratam{s_1}(r) \sqcup \Fstratam{s_2}(\Fstratap{s_1}(r)) \\
    \Bstratap{\seq{s_1}{s_2}}(r,p) &= \Bstratap{s_1}(r,\Bstratap{s_2}(\Fstratap{s_1}(r,p)) \\
    \Bstratam{\seq{s_1}{s_2}}(r,p) &= \Bstratam{s_1}(r,p) \sqcup \Bstratap{s_1}(r,\Bstratam{s_2}(\Fstratap{s_1},p))
  \end{align*}

\item Case $s = \choice{s_1}{s_2}$:
  %
  \begin{align*}
    \Fstratap{\choice{s_1}{s_2}}(r) &= \Fstratap{s_1}(r) \sqcup \Fstratap{s_2}(r) \\
    \Fstratam{\choice{s_1}{s_2}}(r) &= \Fstratam{s_1}(r) \sqcap \Fstratam{s_2}(r) \\
    \Bstratap{\choice{s_1}{s_2}}(r,p) &= \Bstratap{s_1}(r,p) \sqcup \Bstratap{s_2}(r,p) \\
    \Bstratam{\choice{s_1}{s_2}}(r,p) &= \Bstratam{s_1}(r,p) \sqcap \Bstratam{s_2}(r,p)
  \end{align*}

\item Case $s = \leftchoice{s_1}{s_2}$:
  %
  \begin{align*}
    \Fstratap{\leftchoice{s_1}{s_2}}(r) &= \Fstratap{s_1}(r) \sqcup \Fstratap{s_2}(\Bstratam{s_1}(r)) \\
    \Fstratam{\leftchoice{s_1}{s_2}}(r) &= \Fstratam{s_1}(r) \sqcap \Fstratam{s_2}(r) \\
    \Bstratap{\leftchoice{s_1}{s_2}}(r,p) &= \Bstratap{s_1}(r,p) \sqcup \Bstratap{s_2}(\Bstratam{s_1}(r),p) \\
    \Bstratam{\leftchoice{s_1}{s_2}}(r,p) &= \Bstratam{s_1}(r,p) \sqcap \Bstratam{s_2}(r,p)
  \end{align*}

\item Case $s = \fix{x}{s'}$:
  %
  \begin{align*}
    \Fstratap{\fix{x}{s'}}(r) &= \Fstratap{s'[x \coloneqq \fix{x}{s'}]}(r) \\
    \Fstratam{\fix{x}{s'}}(r) &= \Fstratam{s'[x \coloneqq \fix{x}{s'}]}(r) \\
    \Bstratap{\fix{x}{s'}}(r,p) &= \Bstratap{s'[x \coloneqq \fix{x}{s'}]}(r,p) \\
    \Bstratam{\fix{x}{s'}}(r,p) &= \Bstratam{s'[x \coloneqq \fix{x}{s'}]}(r,p)
  \end{align*}

\item Case $s = \path{i}{s'}$:
  %
  \begin{align*}
    \Fstratap{\path{i}{s'}}(r) &= \fpathp(i,r,\Fstratap{s'}) \\
    \Fstratam{\path{i}{s'}}(r) &= \fpathm(i,r,\Fstratam{s'}) \\
    \Bstratap{\path{i}{s'}}(r,p) &= \bpathp(i,r,p,\Fstratap{s'}) \\
    \Bstratam{\path{i}{s'}}(r,p) &= \bpathm(i,r,p,\Fstratam{s'})
  \end{align*}
  %
  where
  \begin{align*}
    \fpathp(i,r,F^\triangleright_\plus) \sqsupseteq\ &
       \absstate(\lbrace\
            (f(t_1,\ldots,t_i',\ldots,t_n),\rho')\ |\ 
            \exists (f(t_1,\ldots,t_i,\ldots,t_n),\rho) \in \constate(r). \ 
            1 \leq i \leq n\
            \land\ (t_i',\rho') \in \constate(F^\triangleright_\plus)(\absstate(\lbrace (t_i,\rho) \rbrace))\ \rbrace) \\
    \fpathm(i,r,F^\triangleright_\minus) \sqsupseteq\ & 
        \absfail(\lbrace \fail\ |\ \exists f(t_1\ldots t_n) \in \constate(r). i > n \lor (1 \leq i \leq n\ \land\ \fail\ \in \confail(F^\triangleright_\minus(\absstate(\lbrace (t_i,\rho) \rbrace))))\ \rbrace) \\
    \bpathp(i,r,p,F^\triangleright_\plus) \sqsupseteq\ &
       \absstate(\lbrace\ 
           (f(t_1,\ldots,t_i,\ldots,t_n),\rho) \in \constate(r)\ |\ 
             \exists (f(t_1,\ldots,t_i',\ldots,t_n),\rho') \in \constate(p).\ 
             (t_i',\rho') \in \constate(F^\triangleright_\plus)(\absstate(\lbrace (t_i,\rho) \rbrace))\ \rbrace) \\
    \bpathm(i,r,p,F^\triangleright_\minus) \sqsupseteq\ &
       \absstate(\lbrace\ 
           (f(t_1,\ldots,t_i,\ldots,t_n),\rho) \in \constate(r)\ |\ 
             \exists \fail\ \in \confail(p).\ 
             i > n \lor (1 \leq i \leq n\ \land\ \fail \in \confail(F^\triangleright_\minus)(\absstate(\lbrace (t_i,\rho) \rbrace)))\ \rbrace)
  \end{align*}

\item Case $s = \all{s'}$:
  \begin{align*}
    \Fstratap{\all{s'}}(r) &= \fallap(r,\Fstratap{s'}) \\
    \Fstratam{\all{s'}}(r) &= \fallam(r,\Fstratap{s'},\Fstratam{s'}) \\
    \Bstratap{\all{s'}}(r,p) &= \ballap(\Bstratap{s'})(r,p) \\
    \Bstratam{\all{s'}}(r,p) &= \ballam(\Fstratap{s'},\Fstratam{s'},
                                         \Bstratap{s'},\Bstratam{s'})(r,p)
  \end{align*}
  %
  where
  %
  \begin{align*}
%     \foldap &: (\Statea \rightarrow \Statea) \times \Statea \rightarrow \Statea \\
%     \foldam &: (\Statea \rightarrow \Statea) \times
%                (\Statea \rightarrow \Statefail) \times \Statea \rightarrow \Statefail \\
%     \bfoldap &: (\Statea \times \Statea \rightarrow \Statea) \rightarrow \Statea \\
%     \bfoldam &: (\Statea \rightarrow \Statea) \rightarrow \Statea \\
%     \bfoldam &: (\Statea \rightarrow \Statea \times
%                  \Statea
% ) \rightarrow \Statea \\
  \end{align*}
  

\end{itemize}

Since
\begin{align*}
  \alpha^\star(\Fstratp{s})R &\sqsubseteq \Fstratap{s}R \\
  \alpha^\star(\Fstratm{s})R &\sqsubseteq \Fstratam{s}R,
\end{align*}
it holds that
\begin{align*}
   &\ \alpha^\star(\Fstrata{s})R \\
  =&\ \ddot{\alpha}(\Fstratp{s}(\dot{\gamma}(r)) \cup \Fstratm{s}(\dot{\gamma}(r))) \\
  \sqsubseteq&\ \ddot{\alpha}(\Fstratp{s}(\dot{\gamma}(r))) \sqcup \ddot{\alpha}(\Fstratm{s}(\dot{\gamma}(r))) \\
  \sqsubseteq&\ \Fstratap{s}R \sqcup \Fstratam{s}R \\
  =&\ \Fstrata{s}R
\end{align*}
if $\ddot{\alpha}$ satisfies
\begin{align*}
  \ddot{\alpha}(M \cup N) \sqsubseteq \ddot{\alpha}(M) \sqcup \ddot{\alpha}(N)
\end{align*}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
