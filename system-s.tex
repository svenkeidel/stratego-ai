\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{enumerate}

\usepackage[]{stix}
\usepackage{amsmath,amsfonts}
%\setlength{\mathindent}{0pt}
\allowdisplaybreaks

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}[theorem]{Example}

\usepackage{listings}
\lstset{mathescape=true}
\newcommand{\lst}[1]{\lstinline!#1!}

\usepackage{bcprules}

\usepackage{tikz,tikz-cd}
\tikzset{%
  symbol/.style={%
    draw=none,
    every to/.append style={%
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}

% custom macros
\newcommand{\minus}{{\scalebox{0.9}{-}}}
\newcommand{\plus}{{\scalebox{0.6}{\!+}}}
\newcommand{\squarediamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1) (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\renewcommand{\square}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (0,0) rectangle (1,1);}}}
\renewcommand{\diamond}{\mathbin{\text{\tikz [x=1ex,y=1ex,scale=1.5,line width=.1ex,line join=round] \draw (.5\pgflinewidth,.5) -- (.5,1ex-.5\pgflinewidth) -- (1ex-.5\pgflinewidth,.5) -- (.5,.5\pgflinewidth) -- (.5\pgflinewidth,.5) -- cycle;}}}
\newcommand{\state}[1]{\ensuremath \langle #1 \rangle}
\newcommand{\transition}[2]{\ensuremath \state{#1} & \longrightarrow \state{#2}}
\newcommand{\termrule}[3]{\ensuremath #1 \xrightarrow{#2} #3}
\newcommand{\fail}{\ensuremath \text{$\uparrow$}}
\newcommand{\success}{\ensuremath \text{$\downarrow$}}
\newcommand{\cont}[2]{\ensuremath \mathbf{#1}(#2)}
\newcommand{\return}{\ensuremath \hookleftarrow}
\newcommand{\seq}[2]{\ensuremath #1 ; #2}
\newcommand{\choice}[2]{\ensuremath #1 \triangledown #2}
\newcommand{\leftchoice}[2]{\ensuremath #1 \smalltriangleleft #2}
\newcommand{\fix}[2]{\ensuremath \operatorname{rec}(#1,#2)}
\newcommand{\path}[2]{\ensuremath \operatorname{path}(#1,#2)}
\newcommand{\one}[1]{\ensuremath \operatorname{one}(#1)}
\newcommand{\all}[1]{\ensuremath \operatorname{all}(#1)}
\newcommand{\some}[1]{\ensuremath \operatorname{some}(#1)}
\newcommand{\congr}[1]{\ensuremath \operatorname{cong}(#1)}
\newcommand{\match}[1]{\ensuremath \operatorname{match}(#1)}
\newcommand{\build}[1]{\ensuremath \operatorname{build}(#1)}
\newcommand{\where}[1]{\ensuremath \operatorname{where}(#1)}
\newcommand{\test}[1]{\ensuremath \operatorname{test}(#1)}
\newcommand{\scope}[2]{\ensuremath \lbrace #1 : #2 \rbrace}
\newcommand{\vars}[1]{\ensuremath \text{vars}(#1)}
\newcommand{\alt}{\ensuremath \; | \;}
\newcommand{\subst}[3]{\ensuremath #1[#2 / #3]}

\newcommand{\transform}[5]{#1, #2 \xrightarrow{#3} #4, #5}
\newcommand{\transformx}[4]{#1, #2 \xrightarrow{#3} #4}
\newcommand{\transformfail}[3]{#1, #2 \xrightarrow{#3} \fail}
\newcommand{\dom}{\ensuremath \operatorname{dom}}
\newcommand{\cod}{\ensuremath \operatorname{cod}}
\newcommand{\cjm}{\ensuremath \xmapsto{\text{\tiny cjm}}}
\newcommand{\mon}{\ensuremath \xmapsto{\text{\tiny mon}}}

\newcommand{\Term}{\ensuremath \mathit{Term}}
\newcommand{\Fail}{\ensuremath \text{$\Uparrow$}}
\newcommand{\Success}{\ensuremath \text{$\Downarrow$}}
\newcommand{\Var}{\ensuremath \mathit{Var}}
\newcommand{\Constructor}{\ensuremath \Cat{Con}}
\newcommand{\Env}{\ensuremath \Var \mapsto \Term}
\newcommand{\Pow}{\ensuremath \mathscr{P}}
\newcommand{\sem}[1]{\ensuremath \lBrack #1 \rBrack}
\newcommand{\Disc}[1]{\ensuremath \left\vert #1 \right\vert}
\newcommand{\Cat}[1]{\ensuremath \mathbf{#1}}
\newcommand{\Nat}{\ensuremath \mathbb{N}}
\newcommand{\Hom}[1]{\ensuremath #1}
\newcommand{\twoHom}[1]{\ensuremath #1}

\newcommand{\State}{\ensuremath \mathit{\Sigma} }
\newcommand{\Statea}{\ensuremath \widehat{\State}}

\newcommand{\setbuild}[2]{\ensuremath \{\, #1 \mid #2 \,\}}
\newcommand{\setbuildc}[1]{\ensuremath \{\, #1 \,\}}

\newcommand{\id}{\ensuremath \operatorname{id}}
\newcommand{\Rel}{\ensuremath \Cat{Rel}}
\newcommand{\Naive}{\ensuremath \Cat{Naive}}
\newcommand{\adjoint}{\ensuremath \dashv}
\newcommand{\lub}{\ensuremath \bigsqcup}
\newcommand{\glb}{\ensuremath \bigsqcap}

\newcommand{\SAlgebra}{\ensuremath \mathcal{S}\text{-algebra}}
\newcommand{\SAlgebras}{\ensuremath \mathcal{S}\text{-algebras}}
\newcommand{\SAlg}{\ensuremath \Cat{SAlg}}
\newcommand{\domain}{\ensuremath \operatorname{domain}}
\newcommand{\lfail}{\ensuremath \operatorname{fail}}
\newcommand{\lsucc}{\ensuremath \operatorname{succ}}
\newcommand{\get}{\ensuremath \operatorname{get}}
\newcommand{\map}{\ensuremath \operatorname{map}}
\newcommand{\arity}{\ensuremath \operatorname{arity}}
\newcommand{\arityeq}{\ensuremath \operatorname{arityeq}}
\newcommand{\aritylt}{\ensuremath \operatorname{aritylt}}
\newcommand{\arityneq}{\ensuremath \operatorname{arityneq}}
\newcommand{\coneq}{\ensuremath \operatorname{coneq}}
\newcommand{\conneq}{\ensuremath \operatorname{conneq}}
\newcommand{\ttop}{\ensuremath \top_{\Term}}
\newcommand{\tbot}{\ensuremath \bot_{\Term}}
\newcommand{\comp}{\ensuremath \mathrel{\circ}}
\newcommand{\Comp}{\ensuremath \mathop{\bigcirc}}
\newcommand{\witharity}{\ensuremath \Join}
\newcommand{\iso}{\ensuremath \cong}
\newcommand{\lfix}{\ensuremath \operatorname{rec}}
\newcommand{\FAlg}{\ensuremath F\text{-Alg}}
\newcommand{\TwoAdj}{\ensuremath 2\text{-Adj}}

\begin{document}

\section{Abstract Interpretation of System S}

\begin{definition}[Operational semantics of System S] \normalfont
\end{definition}

\infrule[Test]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\test{s}}{t}{\rho}}

\infrule[Test-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\test{s}}}

\infrule[Neg]
  {\transformfail{t}{\rho}{s}}
  {\transform{t}{\rho}{\neg s}{t}{\rho}}

\infrule[Neg-Fail]
  {\transform{t}{\rho}{s}{t'}{\rho'}}
  {\transformfail{t}{\rho}{\neg s}}

\infrule[Seq]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transform{t'}{\rho'}{s_2}{t''}{\rho''}}
  {\transform{t}{\rho}{\seq{s_1}{s_2}}{t''}{\rho''}}

\infrule[Seq-Fail-1]
  {\transformfail{t}{\rho}{s_1}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Seq-Fail-2]
  {\transform{t}{\rho}{s_1}{t'}{\rho'} \andalso \transformfail{t'}{\rho'}{s_2}}
  {\transformfail{t}{\rho}{\seq{s_1}{s_2}}}

\infrule[Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-2]
  {\transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\choice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Left-Choice-1]
  {\transform{t}{\rho}{s_1}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-2]
  {\transformfail{t}{\rho}{s_1} \andalso \transform{t}{\rho}{s_2}{t'}{\rho'}}
  {\transform{t}{\rho}{\leftchoice{s_1}{s_2}}{t'}{\rho'}}

\infrule[Left-Choice-Fail]
  {\transformfail{t}{\rho}{s_1} \andalso \transformfail{t}{\rho}{s_2}}
  {\transformfail{t}{\rho}{\choice{s_1}{s_2}}}

\infrule[Rec]
  {\transform{t}{\rho}{\subst{s}{x}{\fix{x}{s}}}{t'}{\rho'}}
  {\transform{t}{\rho}{\fix{x}{s}}{t'}{\rho'}}

\infrule[Rec-Fail]
  {\transformfail{t}{\rho}{\subst{s}{x}{\fix{x}{s}}}}
  {\transformfail{t}{\rho}{\fix{x}{s}}}

\infrule[Path]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[Path-Fail]
  {\transformfail{t_i}{\rho}{s}}
  {\transformfail{f(\ldots,t_i,\ldots)}{\rho}{\path{i}{s}}}

\infrule[Path-Fail-Bounds]
  {i > n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\path{i}{s}}}

\infrule[Cong]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\congr{f,s_1,\ldots,s_n}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Cong-Fail]
  {\transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{\congr{f,s_1,\ldots,s_n}}}

\infrule[Cong-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\congr{g,t_1',\ldots,t_n'}}}

\infrule[Cong-Arity-Fail]
  {n \neq n'}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\congr{g,t_1',\ldots,t_{n'}'}}}

\infrule[One]
  {\transform{t_i}{\rho}{s}{t_i'}{\rho'}}
  {\transform{f(\ldots,t_i,\ldots)}{\rho}{\one{s}}{f(\ldots,t_i',\ldots)}{\rho'}}

\infrule[One-Fail]
  {\transformfail{t_i}{\rho}{s} \text{ for all } 1 \leq i \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\one{s}}}

\infrule[All]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[All-Fail]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } 1 \leq i < k \andalso \transformfail{t_k}{\rho_k}{s_k} \andalso k \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho_1}{\all{s}}}

\infrule[Some]
  {\transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}} \text{ for all } i \in M \\
   \transformfail{t_j}{\rho_j}{s} \land\ \rho_{j+1} = \rho_j \land t_j' = t_j \text{ for all } j \in \overline{M} \\
   M \subseteq \lbrace 1 \ldots n \rbrace}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\some{s}}{f(t_1',\ldots,t_n')}{\rho_{n+1}}}

\infrule[Some-Fail]
  {\transformfail{t_i}{\rho}{s} \text{ for all } 1 \leq i \leq n}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\some{s}}}

\infrule[Match-Not-In-Dom]
  {x \notin \dom{\rho}}
  {\transform{t}{\rho}{\match{x}}{t}{\rho[x \mapsto t]}}

\infrule[Match-In-Dom]
  {\rho(x) = t}
  {\transform{t}{\rho}{\match{x}}{t}{\rho}}

\infrule[Match-In-Dom-Fail]
  {\rho(x) \neq t}
  {\transformfail{t}{\rho}{\match{x}}}

\infrule[Match-Sub]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Sub-Fail]
  {\transform{t_i}{\rho_i}{\match{t_i'}}{t_i}{\rho_{i+1}} \text{ for all } 1 \leq i < k \\
   \transformfail{t_k}{\rho_k}{\match{t_k'}} \\
   k \leq n}
  {\transform{f(t_1,\ldots,t_n)}{\rho_1}{\match{f(t_1',\ldots,t_n')}}{f(t_1,\ldots,t_n)}{\rho_n}}

\infrule[Match-Con-Fail]
  {f \neq g}
  {\transformfail{f(t_1,\ldots,t_n)}{\rho}{\match{g(t_1',\ldots,t_n')}}}

\infrule[Build]
  {\vars{t'} \subseteq \dom{\rho}}
  {\transform{t}{\rho}{\build{t'}}{\rho(t')}{\rho}}

\infrule[Build-Fail]
  {\vars{t'} \nsubseteq \dom{\rho}}
  {\transformfail{t}{\rho}{\build{t'}}}

\infrule[Where]
  {\transform{t}{\rho}{s}{\rho(t')}{\rho'}}
  {\transform{t}{\rho}{\where{s}}{t}{\rho'}}

\infrule[Where-Fail]
  {\transformfail{t}{\rho}{s}}
  {\transformfail{t}{\rho}{\where{s}}}

\infrule[Scope]
  {\transform{t}{\rho \setminus \mathbf{x}}{s}{t'}{\rho'}}
  {\transform{t}{\rho}{\scope{\mathbf{x}}{s}}{t'}{(\rho' \setminus \mathbf{x}) \cup (\rho | \mathbf{x})}}

\infrule[Scope-Fail]
  {\transformfail{t}{\rho \setminus \mathbf{x}}{s}}
  {\transformfail{t}{\rho}{\scope{\mathbf{x}}{s}}}

\par\medskip

\begin{definition}[Strict 2-Cateogry] \normalfont
  A 2-category $\Cat{C}$ consists of
  \begin{itemize}
  \item a collection of objects,
  \item a collection $\Hom{\Cat{C}}(A,B)$ of 1-morphisms between objects $A,B$,
  \item a collection $\Hom{\Cat{C}}(f,g)$ of 2-morphisms between 1-morphisms $f,g$,
  \item for all objects $A$, a 1-morphism \emph{identity} \[\id_A:A \rightarrow B,\]
  \item for all 1-morphisms $f$, a 2-morphism \emph{identity} \[\id_f:f \Rightarrow f,\]
  \item for all 1-morphisms $f:A \rightarrow B,g:B \rightarrow C$, a 1-morphism \emph{composition} \[g \comp f: A \rightarrow C, \]
  \item for all 2-morphisms \begin{tikzcd} f \ar[r,Rightarrow,"\eta"] & g \ar[r,Rightarrow,"\theta"] & h \end{tikzcd} a 2-morphism \emph{composition} \[\theta \comp \eta: h \Rightarrow f, \]
  \end{itemize}
  satisfying the following laws,
  \begin{itemize}
  \item for all 1-morphisms $f: A \rightarrow B$, $f \comp \id_A = f = \id_B \comp f$ as indicated in the commuting diagram
  \[
    \begin{tikzcd}
      A \ar[r,"\id_A"] \ar[dr,"f \comp \id_A"below] & A \ar[d,"f"left] \ar[dr,"\id_B \comp f"right] &   \\
                                                    & B \ar[r,"\id_B"below] & B,
    \end{tikzcd}
  \]
  \item for all 1-morphisms $f,g: A \rightarrow B$, and 2-morphism $\eta: f \rightarrow g$, $\eta \comp \id_f = \eta = \id_g \comp \eta$ as indicated in the commuting diagram
  \[
    \begin{tikzcd}
      f \ar[r,Rightarrow,"\id_f"] \ar[dr,Rightarrow,"\eta \comp \id_f"below] & f \ar[d,Rightarrow,"\eta"left] \ar[dr,Rightarrow,"\id_g \comp \eta"right] &   \\
                                                       & g \ar[r,Rightarrow,"\id_g"below] & g,
    \end{tikzcd}
  \]
  \item for all 1-morphisms \begin{tikzcd} A \ar[r,"f"] & B \ar[r,"g"] & C \ar[r,"h"] & D, \end{tikzcd} $(h \comp g) \comp f = h \comp (g \comp f)$ as indicated in the commuting diagram
  \[
    \begin{tikzcd}
      A \ar[r,"f"] \ar[rr,bend left,"g \comp f"] \ar[rrr,bend left=50,"h \comp (g \comp f)"] \ar[rrr,bend right=50,"(h \comp g) \comp f"below] & B \ar[r,"g"] \ar[rr,bend right,"h \comp g" below] & C \ar[r,"h"] & D
    \end{tikzcd}
  \]
  \item for all 1-morphisms $f,g,h,i : A \rightarrow B$, and all 2-morphisms \begin{tikzcd} f \ar[r,Rightarrow,"\eta"] & g \ar[r,Rightarrow,"\theta"] & h \ar[r,Rightarrow,"\iota"] & i, \end{tikzcd} $(\iota \comp \theta) \comp \eta = \iota \comp (\theta \comp \eta)$ as indicated in the commuting diagram
  \[
    \begin{tikzcd}
      f \ar[r,Rightarrow,"\eta"] \ar[rr,Rightarrow,bend left,"\theta \comp \eta"] \ar[rrr,Rightarrow,bend left=50,"\iota \comp (\theta \comp \eta)"] \ar[rrr,Rightarrow,bend right=50,"(\iota \comp \theta) \comp \eta"below] & g \ar[r,Rightarrow,"\theta"] \ar[rr,Rightarrow,bend right,"\iota \comp \theta" below] & h \ar[r,Rightarrow,"\iota"] & i
    \end{tikzcd}
  \]
  \end{itemize}
\end{definition}

\begin{definition}[Lax Functor] \normalfont
  An Lax functor $F$ between two 2-categories $\Cat{C}, \Cat{D}$ preserves identities and composition only up to 2-morphism, that is, it consists of 
  \begin{itemize}
  \item for all objects $A$ in $\Cat{C}$, an object $F(A)$ in $\Cat{D}$,
  \item for all objects $A,B$ in $\Cat{C}$, a functor \[ F(A,B) : \Hom{\Cat{C}}(A,B) \rightarrow \Hom{\Cat{D}}(F(A),F(B)), \]
  \item for all objects $A$ in $\Cat{C}$, a 2-morphism in $\Cat{D}$ \[ F(\id_A) : \id_{F(A)} \Rightarrow F(A,A)(\id_A)  \]
  \item for all arrows $f:A \rightarrow B, g:B \rightarrow C$ in $\Cat{C}$, a 2-morphism in $\Cat{D}$ \[F(g \comp f) : F(B,C)(g) \comp F(A,B)(f) \Rightarrow F(A,C)(g \comp f) \]
  \end{itemize}
\end{definition}

\begin{definition}[Oplax Functor] \normalfont
  An oplax functor $F$ between two 2-categories $\Cat{C}, \Cat{D}$ preserves identities and composition only up to 2-morphism, that is, it consists of 
  \begin{itemize}
  \item for all objects $A$ in $\Cat{C}$, an object $F(A)$ in $\Cat{D}$,
  \item for all objects $A,B$ in $\Cat{C}$, a functor \[ F(A,B) : \Hom{\Cat{C}}(A,B) \rightarrow \Hom{\Cat{D}}(F(A),F(B)), \]
  \item for all objects $A$ in $\Cat{C}$, a 2-morphism in $\Cat{D}$ \[ F(\id_A) : F(A,A)(\id_A) \Rightarrow \id_{F(A)} \]
  \item for all arrows $f:A \rightarrow B, g:B \rightarrow C$ in $\Cat{C}$, a 2-morphism in $\Cat{D}$ \[F(g \comp f) : F(A,C)(g \comp f) \Rightarrow F(B,C)(g) \comp F(A,B)(f) \]
  \end{itemize}
\end{definition}

\begin{definition}[Adjunction] \normalfont
  An adjunction is a pair of functors, \[\begin{tikzcd} \Cat{C}\ar[r,bend left,"\alpha",""{name=A,below}] & \mathcal{D}\ar[l,bend left,"\gamma",""{name=B,above}]\ar[from=A, to=B, symbol=\dashv], \end{tikzcd}\] s.t. for all objects $A$ in $\Cat{C}$, and $B$ in $\Cat{D}$, \[ \Hom{\Cat{D}}(\alpha(A),B) \iso \Hom{\Cat{C}}(A,\gamma(B)) \]
\end{definition}

\begin{definition}[2-Adjunction] \normalfont
  An 2-adjunction is a pair of 2-functors, \[\begin{tikzcd} \Cat{C}\ar[r,Rightarrow,bend left,"\alpha",""{name=A,below}] & \mathcal{D}\ar[l,Rightarrow,bend left,"\gamma",""{name=B,above}]\ar[from=A, to=B, symbol=\dashv], \end{tikzcd}\] s.t. for all 1-morphisms $f$ in $\Cat{C}$, and $g$ in $\Cat{D}$, \[ \twoHom{\Cat{D}}(\alpha(f),g) \iso \twoHom{\Cat{C}}(f,\gamma(g)) \]
\end{definition}

\begin{definition}[$\SAlgebra$] \normalfont
  An $\SAlgebra$, is an algebra of operations that abstractly describe term rewriting relations. The algebra consists of
  \begin{itemize}
    \item a 2-category $\Cat{C}$ where 2-morphism form a complete partial order $\sqsubseteq$. Then in particular 2-products between two 1-morphisms $f,g$ in $\Cat{C}$ are greatest lower bounds (with respect to $\sqsubseteq$) as indicated in
    \[
       \begin{tikzcd}
           & h \ar[dl,Rightarrow] \ar[d,Rightarrow,dotted] \ar[dr,Rightarrow] &   \\
         f & f \sqcap g \ar[l,Rightarrow] \ar[r,Rightarrow] & g,
       \end{tikzcd}
    \]
    and 2-coproducts are least upper bounds
    \[
       \begin{tikzcd}
         f\ar[dr,Rightarrow] \ar[r,Rightarrow]  & f \sqcup g \ar[d,Rightarrow,dotted] & g \ar[dl,Rightarrow] \ar[l,Rightarrow] \\
         & h. &
       \end{tikzcd}
    \]
    \item an operation to represent the indentity relation on the domain \[\domain : \Hom{\Cat{C}}(A,B) \rightarrow \Hom{\Cat{C}}(A,A) \] of a given relation,
    \item an operation to represent success \[\lsucc : \Disc{\Cat{C}} \rightarrow \Cat{C} \] and failure \[\lfail : \Disc{\Cat{C}} \rightarrow \Cat{C} \] of a strategy,
    \item an operation to retrieve the $i$th immediate subterm \[\get : \Disc{\Cat{C}} \times \Nat \rightarrow \Cat{C} \]
    \item an operation to apply a strategy to the $i$th immediate subterm \[\map : \Disc{\Cat{C}} \times \Nat \times \Cat{C} \rightarrow \Cat{C} \]
    \item an operation to assert if the top most constructor is equal \[\coneq : \Disc{\Cat{C}} \times \Constructor \rightarrow \Cat{C} \] or not equal \[ \conneq : \Disc{\Cat{C}} \times \Constructor \rightarrow \Cat{C} \] to the given constructor,
    \item an operation to assert if the arity of the top level constructor is equal \[\arityeq : \Disc{\Cat{C}} \times \Nat \rightarrow \Cat{C} \] or lower \[\aritylt : \Disc{\Cat{C}} \times \Nat \rightarrow \Cat{C} \] than a certain number,
    \item an operation to apply a different strategies for different arities of the top most constructors
      \begin{align*}
        \witharity : (\Nat \rightarrow \Cat{C}) \rightarrow \Cat{C}
      \end{align*}
    \item an operation to represent an recursive call of a strategy \[\lfix : \Cat{C} \rightarrow \Cat{C}\]
  \end{itemize}

  We write $\SAlg(\Cat{C})$ for an $\SAlgebra$ with the underlying category $\Cat{C}$. A morphism between two $\SAlgebras$
  \[\begin{tikzcd}
      \SAlg(\Cat{C})\arrow{r}{ (\alpha ,\gamma) } & \SAlg(\Cat{D})
    \end{tikzcd}\]
  is a pair of 2-functors $\alpha,\gamma$, that form a 2-adjunction
  \[\begin{tikzcd}
      \Cat{C}\ar[r,Rightarrow,bend left,"\alpha",""{name=A,below}] & \Cat{D}\ar[l,Rightarrow,bend left,"\gamma",""{name=B,above}]\ar[from=A, to=B, symbol=\dashv],
    \end{tikzcd}\]
  and $\alpha$ is oplax, i.e. preserves the algebraic operations of the $\SAlgebras$ up to sound overapproximation, that is, for all objects $A$ and arrows $f$ in $\Cat{C}$, $i \in \mathbb{N}$ and $c \in \Constructor$,
  \begin{align*}
    \alpha(\id_A) &\Rightarrow \id_{\alpha(A)} \\
    \alpha(f \comp g) &\Rightarrow \alpha(f) \comp \alpha(g) \\
    \alpha(f \sqcup g) &\Rightarrow \alpha(f) \sqcup \alpha(g) \\
    \alpha(f \sqcap g) &\Rightarrow \alpha(f) \sqcap \alpha(g) \\
    \alpha(\domain(f)) &\Rightarrow \domain(\alpha(f)) \\
    \alpha(\lsucc(A)) &\Rightarrow \lsucc(\alpha(A)) \\
    \alpha(\lfail(A)) &\Rightarrow \lfail({\alpha(A)}) \\
    \alpha(\get(A,i)) &\Rightarrow \get(\alpha(A),i) \\
    \alpha(\map(A,i)) &\Rightarrow \map(\alpha(A),i) \\
    \alpha(\coneq(A,c)) &\Rightarrow \coneq(\alpha(A),c) \\
    \alpha(\conneq(A,c)) &\Rightarrow \conneq(\alpha(A),c) \\
    \alpha(\arityeq(A,i)) &\Rightarrow \arityeq(\alpha(A),i) \\
    \alpha(\aritylt(A,i)) &\Rightarrow \aritylt(\alpha(A),i) \\
    \alpha(\witharity_{n} f_n) &\Rightarrow \witharity_{n} \alpha(f_n) \\
    \alpha(\lfix(f)) &\Rightarrow \lfix(\alpha(f))
  \end{align*}
\end{definition}

\begin{example} \normalfont
  A commuting diagram in $\FAlg(\TwoAdj)$
\[\begin{tikzcd}[column sep=2cm,row sep=2cm]
    F(\Rel(\State)) \arrow{d}{\eta} \arrow{r}{F(\alpha \dashv \gamma)} & F(\Naive) \arrow{d}{\theta} \\
    \Rel(\State)\arrow{r}{\alpha \dashv \gamma} & \Naive
\end{tikzcd}\]
\end{example}

\begin{definition}[$\Rel(\mathcal{U})$ Category] \normalfont
  We define the category of relations $\Rel$, where 
  \begin{itemize}
  \item objects $A,B,C$ are subsets of a universe $\mathcal{U}$,
  \item 1-morphisms $R: A \rightarrow B$ are binary relations $R \subseteq A \times B$,
  \item 2-morphisms $R \Rightarrow S$ are witnesses of the inclusion ordering on relations $R \subseteq S$,
  \item the identity for an object $A$ is the identity relation \[\id_A \coloneq \setbuild{ (x,x) }{ x \in A },\]
  \item composition of 1-morphisms is defined as \[R \circ S \coloneq \setbuild{(x,z)}{ \exists y. (x,y) \in S \land (y,z) \in R }.\]
  \end{itemize}
\end{definition}

\begin{definition}[System S Program State] \normalfont
  The state of System S programs is either a term together with a term environment or a symbol that represents the failure of a strategy \[\State \coloneq \Term \times (\Env) \cup \Fail.\]
\end{definition}

We can think of the objects the category $\Rel(\State)$ as properties of program states, the 1-morphisms as relational properties of two program states and the 2-morphism as implication of two relational properties.

\begin{definition}[$\SAlgebra$ for $\Rel(\State)$] \normalfont
  We define the $\SAlgebra$ $\SAlg(\Rel(\State))$ for binary relations over System S states, where for all objects $A$ and 1-morphisms $R, S$ in $\Rel(\State)$,
  \begin{align*}
    \dom(R) &\coloneq \setbuild{(x,x)}{ \forall (x,y) \in R } \\
    \lsucc(A) &\coloneq \setbuild{((t,\rho),(t,\rho))}{ \forall (t,\rho) \in A } \\
    \lfail(A) &\coloneq \setbuild{(a,\fail)}{\forall a \in A} \\
    \get(A,i) &\coloneq \setbuild{ ((f(\ldots t_i \ldots),\rho), (t_i,\rho)) }{ \forall (f(\ldots),\rho) \in A } \\
    \map(A,i,R) &\coloneq \setbuild{ ((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho)) }{ \forall\, (f(\ldots t_i \ldots),\rho) \in A,\ ((t_i,\rho),(t_i',\rho')) \in R } \\
    \coneq(A,f) &\coloneq \setbuild{ ((g(\ldots),\rho),(g(\ldots),\rho)) }{ \forall (g(\ldots),\rho) \in A.\ f = g } \\
    \conneq(A,f) &\coloneq \setbuild{ ((g(\ldots),\rho),(g(\ldots),\rho)) }{ \forall (g(\ldots),\rho) \in A.\ f \neq g } \\
    \arityeq(A,i) &\coloneq \setbuild{ ((f(\ldots t_j),\rho),(f(\ldots t_j),\rho)) }{ \forall (f(\ldots t_j),\rho) \in A.\ j = i } \\
    \aritylt(A,i) &\coloneq \setbuild{ ((f(\ldots t_j),\rho),(f(\ldots t_j),\rho)) }{ \forall (f(\ldots t_j),\rho) \in A.\ j < i } \\
    \witharity_{A,n} R_n &\coloneq \bigcup_{n \in \Nat} \setbuild{ ((f(\ldots t_n),\rho),x) }{ \forall (f(\ldots t_n) ((f(\ldots t_n),\rho),x) \in R_n } \\
    \lfix(R) &\coloneq R
  \end{align*}
\end{definition}

\begin{definition}[Concrete Denotational Semantics of System S] \normalfont
  We define the denotational semantics of System S programs as a relation over $\State \times \State$ with \[\sem{s} \coloneq \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}.\]
\end{definition}

\begin{lemma} \normalfont
  Since all System-S rules have the form $\transformx{t}{\rho}{s}{x}$, it is easy to see, that \[ \lsucc(\dom(\sem{s})) = \id_{\dom(\sem{s})}. \]
\end{lemma}

\begin{lemma} \normalfont
  For all objects $A$ in $\Rel(\State)$, \[ \lsucc(A) \cup \lfail(\Fail) = \id_{A \cup \Fail} \]
  \begin{proof}
    \begin{align*}
      \lsucc(A) \cup \lfail(\Fail) &= \setbuild{ ((t,\rho),(t,\rho)) }{ (t,\rho) \in A } \cup \setbuildc{ (\fail,\fail) } \\
                                   &= \id_{A \cup \Fail} 
    \end{align*}
  \end{proof}
\end{lemma}

\begin{lemma} \normalfont
  For all relations $P,Q,R,$ in $\Rel(\mathcal{U}),$ \[(P \cup Q) \comp R = P \comp R \cup Q \comp R\]
\begin{proof}
  \begin{align*}
    (P \cup Q) \comp R &= \setbuild{ (x,z) }{ \exists y. (x,y) \in R \land (y,z) \in (P \cup Q) } \\
                       &= \setbuild{ (x,z) }{ \exists y. (x,y) \in R \land ((y,z) \in P \lor (y,z) \in Q) } \\
                       &= \setbuild{ (x,z) }{ \exists y. ((x,y) \in R \land (y,z) \in P) \lor ((x,y) \in R \land (y,z) \in Q)) } \\
                       &= \setbuild{ (x,z) }{ \exists y. (x,y) \in R \land (y,z) \in P } \cup  \setbuild{ (x,z) }{ \exists y. (x,y) \in R \land (y,z) \in Q } \\
                       &= P \comp R \cup Q \comp R
  \end{align*}
  Analogously,
  \begin{align*}
    R \comp (P \cup Q) &= R \comp P \cup R \comp Q \\
    (P \cap Q) \comp R &= P \comp R \cap Q \comp R \\
    R \comp (P \cap Q) &= R \comp P \cap R \comp Q
  \end{align*}
\end{proof}
\end{lemma}

\begin{theorem} \normalfont
  Next, we demonstrate that the concrete semantics of System S can be expressed with operations of an $\SAlgebra$. In the following, we omit writing down all arguments for certain operations to avoid repeating our selves
  \begin{align*}
    \lsucc \comp R &= \lsucc(\cod(R)) \comp R \\
    \lfail \comp R &= \lfail(\cod(R)) \comp R \\
  \end{align*}

 We proceed by fixed-point induction and case distinction on the System S program.
\begin{proof}


\begin{align*}
  \sem{\test{s}}
    &= \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\test{s}}{x}} \\
     &= \setbuild{((t,\rho),(t,\rho))}{\transform{t}{\rho}{s}{t'}{\rho'}} \\
     &\quad \cup \setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s}} \\
     &= \setbuild{ (x,x) }{ (x,y) \in \setbuildc{((t,\rho),(t,\rho))} \comp \setbuild{((t,\rho),y')}{\transformx{t}{\rho}{s}{y'}}} \\
     &\quad \cup \setbuildc{(\fail,\fail)} \comp \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{y}} \\
     &= \domain(\lsucc \comp \sem{s}) \sqcup \lfail(\Fail) \comp \sem{s}
\end{align*}

\begin{align*}
  \sem{\neg{s}}
    &= \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\neg{s}}{x}} \\
    &= \setbuild{((t,\rho),(t,\rho))}{\transformfail{t}{\rho}{s}} \cup \setbuild{((t,\rho),\fail)}{\transform{t}{\rho}{s}{t'}{\rho'}} \\
    &= \domain(\setbuildc{(\fail,\fail)} \comp \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}) \\
    &\quad \cup \setbuildc{\forall (x,\fail)} \comp \domain(\setbuildc{((t,\rho),(t,\rho))} \comp \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}) \\
    &= \domain(\lfail(\Fail) \comp \sem{s}) \sqcup \lfail \comp \domain(\lsucc \comp \sem{s})
\end{align*}

\begin{align*}
  \sem{\seq{s_1}{s_2}}
    &= \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\seq{s_1}{s_2}}{x}} \\
    &= \setbuild{((t,\rho),(t'',\rho''))}{\transform{t}{\rho}{s_1}{t'}{\rho'} \land \transform{t'}{\rho'}{s_2}{t''}{\rho''}}\\
    &\quad \cup \setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s_1}} \\
    &\quad \cup \setbuild{((t,\rho),\fail)}{\transform{t}{\rho}{s_1}{t'}{\rho'} \land \transformfail{t'}{\rho'}{s_2}} \\
    &= \setbuildc{ ((t,\rho),(t,\rho)) } \comp \setbuild{((t,\rho),x)}{\transformx{t'}{\rho'}{s_2}{x}} \\
    &\qquad \comp \setbuildc{ ((t,\rho),(t,\rho)) } \comp \setbuild{((t,\rho),x)}{\transformx{t'}{\rho'}{s_1}{x}} \\
    &\quad \cup \setbuildc{(\fail,\fail)} \comp \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}} \\
    &\quad \cup \setbuildc{(\fail,\fail)} \comp \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_2}{x}} \\
    &\qquad \comp \setbuildc{(t,\rho),(t,\rho))} \comp \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}} \\
    &= \lsucc \comp \sem{s_2} \comp \lsucc \comp \sem{s_1} \\
    &\quad \sqcup \lfail(\Fail) \comp \sem{s_1} \\
    &\quad \sqcup \lfail(\Fail) \comp \sem{s_2} \comp \lsucc \comp \sem{s_1} \\
    &= \lsucc \comp \sem{s_2} \comp \sem{s_1} \sqcup \lfail(\Fail) \comp \sem{s_1} \sqcup \lfail(\Fail) \comp \sem{s_2} \comp \sem{s_1} \\
    &= \left(\lsucc \comp \sem{s_2} \sqcup \lfail(\Fail) \sqcup \lfail(\Fail) \comp \sem{s_2}\right) \comp \sem{s_1} \\
    &= \left(\left(\lsucc \sqcup \lfail(\Fail)\right) \comp \sem{s_2} \sqcup \lfail(\Fail) \right) \comp \sem{s_1} \\
    &= \left(\sem{s_2} \sqcup \lfail(\Fail) \right) \comp \sem{s_1} \\
\end{align*}

\begin{align*}
  \sem{\choice{s_1}{s_2}}
     &= \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\choice{s_1}{s_2}}{x}} \\
     &= \setbuild{((t,\rho),(t',\rho'))}{\transform{t}{\rho}{s_1}{t'}{\rho'}} \\
     &\quad \cup {\setbuild{((t,\rho),(t',\rho'))}{\transform{t}{\rho}{s_2}{t'}{\rho'}}} \\
     &\quad \cup {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s_1} \land \transformfail{t}{\rho}{s_2}}} \\
     &= \setbuildc{((t,\rho),(t,\rho))} \comp {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}}} \\
     &\quad \cup \setbuildc{((t,\rho),(t,\rho))} \comp {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_2}{x}}} \\
     &\quad \cup \left(\setbuildc{(\fail,\fail)} \comp {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}}} \right. \\
     &\qquad\quad \left. \cap \setbuildc{(\fail,\fail)} \comp {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_2}{x}}} \right) \\
     &= \lsucc \comp \sem{s_1} \\
     &\quad \sqcup \lsucc \comp \sem{s_2} \\
     &\quad \sqcup \left(\lfail(\Fail) \comp \sem{s_1} \sqcap \lfail(\Fail) \comp \sem{s_2}) \right) \\
     &= \lsucc \comp (\sem{s_1} \sqcup \sem{s_2}) \sqcup \lfail(\Fail) \comp (\sem{s_1} \sqcap \sem{s_2})
\end{align*}

\begin{align*}
  \sem{\leftchoice{s_1}{s_2}}
     &= {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\leftchoice{s_1}{s_2}}{x}}} \\
     &= {\setbuild{((t,\rho),(t',\rho'))}{\transform{t}{\rho}{s_1}{t'}{\rho'}}} \\
     &\quad \cup {\setbuild{((t,\rho),(t',\rho'))}{\transformfail{t}{\rho}{s_1} \land \transform{t}{\rho}{s_2}{t'}{\rho'}}} \\
     &\quad \cup {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{s_1} \land \transformfail{t'}{\rho'}{s_2}}} \\
     &= {\setbuild{((t,\rho),(t',\rho'))}{\transform{t}{\rho}{s_1}{t'}{\rho'}}} \\
     &\quad \cup {\setbuild{((t,\rho),x)}{\transformfail{t}{\rho}{s_1} \land \transformx{t}{\rho}{s_2}{x}}} \\
     &= {\setbuildc{((t,\rho),(t,\rho))}} \comp {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}}} \\
     & \quad \cup {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_2}{x}}} \\
     &\qquad \comp \setbuild{ (x,x) } { (x,y) \in \setbuildc{(\fail,\fail)} \comp \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s_1}{x}} } \\
     &= \lsucc \comp \sem{s_1} \sqcup \sem{s_2} \comp \domain (\lfail(\Fail) \comp \sem{s_1})
\end{align*}

\begin{align*}
  \sem{\fix{x}{s}}
    &= {\setbuild{((t,\rho),y)}{\transformx{t}{\rho}{\fix{x}{s}}{y}}} \\
    &= {\setbuild{((t,\rho),(t',\rho'))}{\transform{t}{\rho}{\subst{s}{x}{\fix{x}{s}}}{t'}{\rho'}}} \\
    &\quad \cup {\setbuild{((t,\rho),\fail)}{\transformfail{t}{\rho}{\subst{s}{x}{\fix{x}{s}}}}} \\
    &= {\setbuild{((t,\rho),y)}{\transformx{t}{\rho}{\subst{s}{x}{\fix{x}{s}}}{y}}} \\
    &= \sem{\subst{s}{x}{\fix{x}{s}}} \\
    &= \lfix(\sem{\subst{s}{x}{\fix{x}{s}}})
\end{align*}

\begin{align*}
  \sem{\path{i}{s}}
    &= \setbuild{((t,\rho),y)}{\transformx{t}{\rho}{\path{i}{s}}{y}} \\
    &= \setbuild{((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho'))}{\transform{t_i}{\rho}{s}{t_i'}{\rho'}} \\
    &\quad \cup {\setbuild{((f(\ldots t_i \ldots),\rho),\fail)}{\transformfail{t_i}{\rho}{s}}} \\
    &\quad \cup {\setbuild{((f(\ldots t_n),\rho),\fail)}{ n < i }} \\
    &= \setbuild{ ((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho')) }{ ((t_i,\rho),(t_i',\rho')) \in \setbuild{ ((t,\rho),x }{ \transformx{t_i}{\rho}{s}{x} } } \\
    &\quad \cup \setbuildc{ (\fail,\fail)} \comp {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{s}{x}}} \comp {\setbuildc{((f(\ldots t_i \ldots),\rho),(t_i,\rho))}} \\
    &\quad \cup \setbuildc{((t,\rho),\fail)} \comp \setbuild{((f(\ldots t_n),\rho),(f(\ldots t_n),\rho))}{ n < i } \\
    &= \map(i,\sem{s}) \sqcup \lfail \comp \sem{s} \comp \get(i) \sqcup \lfail \comp \aritylt(i) \\
    &= \map(i,\sem{s}) \sqcup \lfail \comp (\sem{s} \comp \get(i) \sqcup \aritylt(i))
\end{align*}

\begin{align*}
  \sem{\congr{f,s_1,\ldots,s_n}}
    &= \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\congr{f,s_1,\ldots,s_n}}{x}} \\
    &= \setbuild{((f(t_1\ldots t_n),\rho_1),(f(t_1'\ldots t_n'),\rho_{n+1}))}{ \forall 1 \leq i \leq n.\ \transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}}} \\
    &\quad \cup \setbuild{((f(t_1\ldots t_n),\rho_1),\fail)}{ \exists k \leq n.\, (\forall 1 \leq i \leq k.\ \transform{t_i}{\rho_i}{s_i}{t_i'}{\rho_{i+1}}) \land \transformfail{t_k}{\rho_k}{s_k}} \\
    &\quad \cup \setbuild{((f(t_1\ldots t_n'),\rho),\fail)}{ n' \neq n } \\
    &\quad \cup \setbuild{((g(\ldots),\rho),\fail)}{ g \neq f } \\
    &= \Comp_{1\leq i \leq n} \setbuild{((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho'))}{ \transform{t_i}{\rho}{s_i}{t_i'}{\rho'} } \\
    &\quad \cup \bigcup_{k \leq n} \left( \setbuild{ ((f(\ldots t_k \ldots),\rho),\fail) }{ \transformx{t_k}{\rho}{s_k}{\fail} } \right. \\
    &\qquad\qquad \left. \comp \mathop{\bigcirc}_{1\leq i < k} \setbuild{((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho'))}{ \transform{t_i}{\rho}{s_i}{t_i'}{\rho'} } \right) \\
    &\quad \cup \setbuildc{ \forall (x,\fail) } \comp \setbuild{((f(t_1\ldots t_n'),\rho),f(t_1\ldots t_n'))}{ n' \neq n } \\
    &\quad \cup \setbuildc{ \forall (x,\fail) } \comp \setbuild{((g(\ldots),\rho),(g(\ldots),\rho))}{ g \neq f } \\
    &= \Comp_{1\leq i \leq n} \setbuild{((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho'))}{ ((t_i,\rho),(t_i',\rho')) \in \setbuild{ ((t,\rho),x) }{ \transform{t_i}{\rho}{s_i}{x} } } \\
    &\quad \cup \bigcup_{k \leq n} \left( \setbuildc{ \forall (x,\fail) } \comp \setbuild{ ((t,\rho),x) }{ \transformx{t}{\rho}{s_k}{x} } \comp \setbuildc{ ((f(\ldots t_k \ldots),\rho),(t_k,\rho)) } \right. \\
    &\qquad\qquad \left. \comp \mathop{\bigcirc}_{1\leq i < k} \setbuild{((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho'))}{ ((t_i,\rho),(t_i',\rho')) \in \setbuild{ ((t,\rho),x) }{ \transformx{t}{\rho}{s_i}{x} } } \right) \\
    &\quad \cup \setbuildc{ \forall (x,\fail) } \comp \setbuild{((f(t_1\ldots t_n'),\rho),f(t_1\ldots t_n'))}{ n' \neq n } \\
    &\quad \cup \setbuildc{ \forall (x,\fail) } \comp \setbuild{((g(\ldots),\rho),(g(\ldots),\rho))}{ g \neq f } \\
    &= \left( \Comp_{1\leq i \leq n} \map(i,\sem{s_i}) \right) \comp \arityeq(n) \comp \coneq(f) \\
    &\quad \sqcup \left( \bigsqcup_{k \leq n} \lfail \comp \sem{s_k} \comp \get(k) \comp \mathop{\bigcirc}_{1 \leq i < k} \map(i,\sem{s_i}) \right) \comp \arityeq(n) \comp \coneq(f) \\
    &\quad \sqcup \lfail \comp \arityneq(n) \\
    &\quad \sqcup \lfail \comp \conneq(f) \\
    &= \left( \left( \Comp_{1\leq i \leq n} \map(i,\sem{s_i}) \right) \sqcup \left( \bigsqcup_{k \leq n} \lfail \comp \sem{s_k} \comp \get(k) \comp \mathop{\bigcirc}_{1 \leq i < k} \map(i,\sem{s_i}) \right) \right) \\
    &\qquad\quad \comp \arityeq(n) \comp \coneq(f) \\
    &\quad \sqcup \lfail \comp \arityneq(n) \\
    &\quad \sqcup \lfail \comp \conneq(f) \\
    &= F_{1,n+1} \comp \arityeq(n) \comp \coneq(f) \\
    &\quad \sqcup \lfail \comp \arityneq(n) \\
    &\quad \sqcup \lfail \comp \conneq(f) \\
\text{where}& \\
  F_{i,n} &= F_{i+1,n} \comp \map(i,\sem{s_i}) \sqcup \lfail \comp \sem{s_i} \comp \get(i) \\
  F_{n,n} &= \id
\end{align*}

\begin{align*}
  \sem{\one{s}}
    &= \setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\one{s}}{x}} \\
    &= \bigcup_{n \in \Nat} \bigcup_{1 \leq i \leq n} \setbuild{((f(\ldots t_i \ldots t_n),\rho),(f(\ldots t_i' \ldots t_n),\rho'))}{\transform{t_i}{\rho}{s}{t_i'}{\rho'}} \\
    &\quad \cup \bigcup_{n \in \Nat} \setbuild{((f(t_1 \ldots t_n),\rho),\fail)}{\forall 1 \leq i \leq n.\, \transformfail{t_i}{\rho}{s}} \\
    &= \witharity_{n} \left( \bigcup_{1 \leq i \leq n} \setbuild{ ((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho')) }{ ((t_i,\rho),(t_i',\rho')) \in \setbuild{ ((t,\rho),x }{ \transformx{t_i}{\rho}{s}{x} } } \right) \\
    &\quad \cup \witharity_{n} \left( \bigcap_{1 \leq i \leq n}  \setbuildc{ \forall (x,\fail) } \comp \setbuild{ ((t,\rho),x)}{ \transformx{t}{\rho}{s}{x} } \comp \setbuildc{ ((f(\ldots t_i \ldots),\rho),(t_i,\rho)) } \right) \\
    &= \witharity_{n} \left( \bigsqcup_{1 \leq i \leq n} \map(i,\sem{s}) \right) \\
    &\quad \sqcup \witharity_{n} \left( \bigsqcap_{1 \leq i \leq n}  \lfail \comp \sem{s} \comp \get(i) \right) \\
    &= \witharity_{n} \left( \bigsqcup_{1 \leq i \leq n} \map(i, \sem{s}) \sqcup \bigsqcap_{1 \leq i \leq n} \lfail \comp \sem{s} \comp \get(i) \right)
\end{align*}

\begin{align*}
  \sem{\all{s}}
    &= {\setbuild{((t,\rho),x)}{\transformx{t}{\rho}{\all{s}}{x}}} \\
    &= {\setbuild{((f(t_i\ldots t_n),\rho_1),(f(t_i'\ldots t_n'),\rho_{n+1}))}{ \forall 1 \leq i \leq n.\ \transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}}}} \\
    &\quad \cup \setbuild { ((f(t_1 \ldots t_n),\rho_1),\fail) }{ \exists k \leq n.\ \left(\forall 1 \leq i < k.\ \transform{t_i}{\rho_i}{s}{t_i'}{\rho_{i+1}}\right) \land \transformfail{t_k}{\rho}{s} } \\
    &= \bigcup_{n \in \mathbb{N}} \mathop{\bigcirc}_{1\leq i \leq n} \setbuild{((f(\ldots t_i \ldots t_n),\rho),(f(\ldots t_i' \ldots t_n),\rho'))}{ ((t_i,\rho),(t_i',\rho')) \in \setbuild{ ((u,\sigma),x) }{ \transformx{u}{\sigma}{s}{x} } } \\
    &\quad \cup \bigcup_{n \in \mathbb{N}} \mathop{\bigcirc}_{1 \leq i \leq n} \setbuild{((f(\ldots t_i \ldots t_n),\rho),(f(\ldots t_i' \ldots t_n),\rho'))}{ ((t_i,\rho),(t_i',\rho')) \in \setbuild{ ((u,\sigma),x) }{ \transformx{u}{\sigma}{s}{x} } } \\
    &\qquad\qquad\qquad  \\
    &= ?
\end{align*}
  
\end{proof}
\end{theorem}

\begin{definition}[$\alpha$-Semantics of System S] \normalfont
  Given a $\SAlgebra$ $\SAlg(L)$ and a morphism between the $\SAlgebras$
  \[
    \begin{tikzcd}
      \SAlg(\Rel(\State)) \arrow{r}{(\alpha ,\gamma)} & \SAlg(L)
    \end{tikzcd},
  \]
  We define the abstract semantics of System S programs as \[\sem{s}_\alpha \coloneq \alpha(\sem{s}). \]
\end{definition}

We begin exploring the space of $\alpha$-Semantics of System S by defining a very naive abstraction, namely where an abstract state consists only of a single term and on conflict we jump immmediatley to top:
 
\begin{definition}[$\Naive$ semantics of System S] \normalfont
  Let $\mathcal{N}$ be the set of abstract program states with $\mathcal{N} = \State \cup \lbrace \top, \bot, \ttop, \tbot \rbrace$. We define a finitely complete partial order (lattice) $\leq_\mathcal{N}$ on $\mathcal{N}$
  \[
    \begin{tikzpicture}
     \matrix (m) [matrix of nodes, row sep=4em, column sep=2em]
    {                              &                        & \node (top) {$\top$};       &                       &                         \\
                                   & \node (ttop){$\ttop$}; &                             &                       &                          \\
      \node (t1) {$(t_1,\rho_1)$}; & \node {\ldots};        & \node (tn) {$(t_n,\rho_n)$}; &                       & \node (fail) {$\fail$}; \\
                                   &                        & \node (bot) {$\bot$};       &                       &                          \\
    };

    \draw [thick] (ttop) -- (top);
    \draw [thick] (fail) -- (top);
    \draw [thick] (t1) -- (ttop);
    \draw [thick] (tn) -- (ttop);
    \draw [thick] (bot) -- (t1);
    \draw [thick] (bot) -- (tn);
    \draw [thick] (bot) -- (fail);
    \end{tikzpicture}
  \]

  Next, we define an $\SAlgebra$ for $\Naive$ where  
  \begin{itemize}
  \item objects $A,B,C \ldots$ are elements of $\mathcal{N}$,
  \item 1-morphisms $(A,B) : A' \rightarrow B'$ are tuples $(A,B) \leq (A',B')$,
  \item 2-morphisms $(A,B) \Rightarrow (A',B')$ is the ordering over $\mathcal{N} \times \mathcal{N}$,
  \end{itemize}
  and
  \begin{align*}
    \id_A &\coloneq (A,A) \\
    (B',C) \comp (A,B) &\coloneq
                \begin{cases}
                  (\bot,\bot), & B \sqcap B' = \bot \\
                  (A,B), & \text{ otherwise}
                \end{cases} \\
    \lsucc(A) &\coloneq
                \begin{cases} 
                  (A,A), & A \leq \ttop \\
                  (\bot,\bot), & A = \fail \\
                  (\top,\top), & A = \top \\
                \end{cases} \\
    \lfail(A) &\coloneq
                \begin{cases} (A,\fail), & \bot < A \leq \ttop \\
                  (\bot,\bot), & A = \bot \lor A = \fail \\
                  (\top,\top), & A = \top \\
                \end{cases} \\
    \get(A,i) &\coloneq
                \begin{cases}
                  ((f(\ldots t_i \ldots),\rho),(t_i,\rho)), & A = (f(\ldots t_i \ldots),\rho) \\
                  (\ttop,\ttop), & A = \ttop \\
                  (\bot,\bot), & A = \bot \lor A = \fail \lor \left(A = (f(\ldots t_n),\rho) \land n < i \right) \\
                  (\top,\ttop), & A = \top \\
                \end{cases} \\
    \map(A,i,r) &\coloneq
                  \begin{cases}
                    ((f(\ldots t_i \ldots),\rho),(f(\ldots t_i' \ldots),\rho')), & A = (f(\ldots t_i \ldots),\rho) \land r = ((t_i,\rho),(t_i',\rho')) \\
                    (\bot,\bot), & A = (f(\ldots t_i \ldots),\rho) \land \dom(r) \neq (t_i,\rho) \\
                    (\bot,\bot), & A = (f(\ldots t_n),\rho) \land n < i \\
                    (A,\ttop), & A = \ttop \lor A = \top \\
                    (\bot,\bot), & A = \bot \lor A = \fail \\
                  \end{cases} \\
    \coneq(A,f) &\coloneq
                  \begin{cases}
                    ((g(\ldots),\rho),(g(\ldots),\rho)), & A = (g(\ldots),\rho) \land f = g \\
                    (\bot,\bot), & A = (g(\ldots),\rho) \land f \neq g \\
                    (\ttop,\ttop), & A = \ttop \\
                    (\top,\ttop), & A = \top \\
                    (\bot,\bot), & A = \bot \lor A = \fail \\
                  \end{cases} \\
    \conneq(A,f) &\coloneq
                   \begin{cases}
                     (A,A), & A = (g(\ldots),\rho) \land f \neq g \\
                     (\bot,\bot), & A = (g(\ldots),\rho) \land f = g \\
                     (\ttop,\ttop), & A = \ttop \\
                     (\top,\ttop), & A = \top \\
                     (\bot,\bot), & A = \bot \lor A = \fail \\
                   \end{cases} \\
    \arity(A,n) &\coloneq
                  \begin{cases}
                    (A,A), & A = (f(\ldots t_m),\rho) \land n = m \\
                    (\bot,\bot), & A = (f(\ldots t_m),\rho) \land n \neq m \\
                    (\ttop,\ttop), & A = \ttop \\
                    (\top,\ttop), & A = \top \\
                    (\bot,\bot), & A = \bot \lor A = \fail \\
                  \end{cases} \\
    \witharity_{A,n} f_n &\coloneq 
  \end{align*}
  
  We continue by defining the abstraction functor $\alpha : \Rel(\State) \rightarrow \Naive$, for objects $X$ by \[\alpha(X) \coloneq \lub X \] and arrows $R$ by \[\alpha(R) \coloneq (\alpha(\setbuild{ x }{ \forall (x,y) \in R }), \alpha(\setbuild{ y }{ \forall (x,y) \in R})). \] The corresponding concretization functor $\gamma : \Naive \rightarrow \Rel(\State)$ is defined by
  \begin{align*}
    \gamma((t,\rho)) &\coloneq \setbuildc{ (t,\rho) } \\
    \gamma(\ttop) &\coloneq \Term \times (\Env) \\
    \gamma(\top) &\coloneq \Term \times (\Env) \cup \Fail \\
    \gamma(\bot) &\coloneq \setbuildc{} \\
  \end{align*}

  We now show, that $(\alpha,\gamma)$ is an morphism between $\SAlgebras$. For all objects X,
  \begin{align*}
    \alpha(\id_X) = (\lub X, \lub X) = \id_{\lub X} = \id_{\alpha(X)}
  \end{align*}
  and for all $R : A \rightarrow B, S : B \rightarrow C$,
  \begin{align*}
    \alpha(S \comp R) &= (\lub A, \lub C) \\
                      &= (\lub B, \lub C) \comp (\lub A, \lub B) \\
                      &= (\alpha(\dom(S)), \alpha(\cod(S))) \comp (\alpha(\dom(R)), \alpha(\cod(R))) \\
                      &= \alpha(S) \comp \alpha(R).
  \end{align*}

  Observe that $R \cup S : X_1 \cup Y_1 \rightarrow X_2 \cup Y_2$ and since $N$ is a complete partial order, it holds that $\forall A,B. \lub(A \cup B) = (\lub A) \sqcup (\lub B),$ then
 \begin{align*}
    \alpha(R \cup S) &= (\lub(X_1 \cup Y_1),\lub(X_2\cup Y_2)) \\
                     &= ((\lub X_1) \sqcup (\lub Y_1), (\lub X_2) \sqcup (\lub Y_2)) \\
                     &= (\lub X_1,\lub X_2) \sqcup (\lub Y_1, \lub Y_2) \\
                     &= \alpha(R) \sqcup \alpha(S).
 \end{align*}
 Analoguosly for meets.
\end{definition}

% \acks{Casper}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
